<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="C++突击面试"><meta name="keywords" content=""><meta name="author" content="Mello13"><meta name="copyright" content="Mello13"><title>C++突击面试 | mello's blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?d5cba8acec7c962be4afb068976dd3fc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#T78RX"><span class="toc-number">1.</span> <span class="toc-text">
1. 编译内存相关
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#q9dN6"><span class="toc-number">1.1.</span> <span class="toc-text">
1.1. C++ 程序编译过程
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xzGVT"><span class="toc-number">1.2.</span> <span class="toc-text">
1.2.
C++ 内存管理
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eODwD"><span class="toc-number">1.3.</span> <span class="toc-text">
1.3. 栈和堆的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mI5WE"><span class="toc-number">1.4.</span> <span class="toc-text">
1.4. 变量的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bFKLo"><span class="toc-number">1.5.</span> <span class="toc-text">
1.5.
全局变量定义在头文件中有什么问题？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C9VlH"><span class="toc-number">1.6.</span> <span class="toc-text">
1.6. 内存对齐
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ST0Qi"><span class="toc-number">1.7.</span> <span class="toc-text">
1.7. 什么是内存泄露
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qswss"><span class="toc-number">1.8.</span> <span class="toc-text">
1.8.
怎么防止内存泄漏？内存泄漏检测工具的原理？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GNx4c"><span class="toc-number">1.9.</span> <span class="toc-text">
1.9.
智能指针有哪几种？智能指针的实现原理？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gVa2p"><span class="toc-number">1.10.</span> <span class="toc-text">
1.10. 一个 unique_ptr
怎么赋值给另一个 unique_ptr 对象？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lBVLR"><span class="toc-number">1.11.</span> <span class="toc-text">
1.11
使用智能指针会出现什么问题？怎么解决？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tLh4C"><span class="toc-number">1.12.</span> <span class="toc-text">
1.12
VS检测内存泄漏，定位泄漏代码位置方法
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#q0vtJ"><span class="toc-number">1.13.</span> <span class="toc-text">
1.13
Linux检测内存泄漏，定位泄漏代码位置方法
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#et1zC"><span class="toc-number">1.14.</span> <span class="toc-text">
1.14 深拷贝与浅拷贝
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dYRLc"><span class="toc-number">2.</span> <span class="toc-text">
2. 语言对比
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ZWjBM"><span class="toc-number">2.1.</span> <span class="toc-text">
2.1 C++ 11 新特性
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CHm4T"><span class="toc-number">2.2.</span> <span class="toc-text">
2.2 C 和 C++ 的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UiX3k"><span class="toc-number">2.3.</span> <span class="toc-text">
2.3 Python 和 C++ 的区别
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PoqTH"><span class="toc-number">3.</span> <span class="toc-text">
3. 面向对象
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#y64KN"><span class="toc-number">3.1.</span> <span class="toc-text">
3.1
什么是面向对象？面向对象的三大特性
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InqgD"><span class="toc-number">3.2.</span> <span class="toc-text">
3.2 重载、重写、隐藏的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VtIyn"><span class="toc-number">3.3.</span> <span class="toc-text">
3.3 如何理解 C++
是面向对象编程
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LWI5v"><span class="toc-number">3.4.</span> <span class="toc-text">
3.4
什么是多态？多态如何实现？
</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EzKGB"><span class="toc-number">3.4.1.</span> <span class="toc-text">
3.4.1 静态多态与动态多态：
</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NRVzM"><span class="toc-number">4.</span> <span class="toc-text">
4. 类相关
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ksfKh"><span class="toc-number">4.1.</span> <span class="toc-text">
5.1
什么是虚函数？什么是纯虚函数？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#yK7oQ"><span class="toc-number">4.2.</span> <span class="toc-text">
5.2 虚函数和纯虚函数的区别？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TilFU"><span class="toc-number">4.3.</span> <span class="toc-text">
5.3 虚函数的实现机制
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a8S9D"><span class="toc-number">4.4.</span> <span class="toc-text">
5.4
单继承和多继承的虚函数表结构
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vq17V"><span class="toc-number">4.5.</span> <span class="toc-text">
5.5
为什么构造函数不能为虚函数？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gqiLq"><span class="toc-number">4.6.</span> <span class="toc-text">
5.6
为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AeAH2"><span class="toc-number">4.7.</span> <span class="toc-text">
5.7
.不能声明为虚函数的有哪些
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#itcw1"><span class="toc-number">5.</span> <span class="toc-text">
5. 关键字库函数
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Z15H9"><span class="toc-number">5.1.</span> <span class="toc-text">
4.1 sizeof 和 strlen 的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Nxflg"><span class="toc-number">5.2.</span> <span class="toc-text">
4.2 lambda
表达式（匿名函数）的具体应用和使用场景
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xoF3Y"><span class="toc-number">5.3.</span> <span class="toc-text">
4.3 explicit
的作用（如何避免编译器进行隐式类型转换）
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vrl3S"><span class="toc-number">5.4.</span> <span class="toc-text">
4.4 C 和 C++ static 的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aW1Z1"><span class="toc-number">5.5.</span> <span class="toc-text">
4.5 static 的作用
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d8HpL"><span class="toc-number">5.6.</span> <span class="toc-text">
4.6 static
在类中使用的注意事项（定义、初始化和使用）
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f5u3W"><span class="toc-number">5.7.</span> <span class="toc-text">
4.7 static
全局变量和普通全局变量的异同
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lAxNP"><span class="toc-number">5.8.</span> <span class="toc-text">
4.8 const 作用及用法
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UkOea"><span class="toc-number">5.9.</span> <span class="toc-text">
4.9 define 和 const 的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#r6Wcu"><span class="toc-number">5.10.</span> <span class="toc-text">
4.10 define 和 typedef
的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cyTb5"><span class="toc-number">5.11.</span> <span class="toc-text">
4.11
用宏实现比较大小，以及两个数中的最小值
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mpIbM"><span class="toc-number">5.12.</span> <span class="toc-text">
4.12 inline 作用及使用方法
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#N1ic8"><span class="toc-number">5.13.</span> <span class="toc-text">
4.13 inline 函数工作原理
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RXyWh"><span class="toc-number">5.14.</span> <span class="toc-text">
4.14
宏定义（define）和内联函数（inline）的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ar9ec"><span class="toc-number">5.15.</span> <span class="toc-text">
4.15 new 的作用？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v0ORN"><span class="toc-number">5.16.</span> <span class="toc-text">
4.16 new 和 malloc
如何判断是否申请到内存？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BMJ7Q"><span class="toc-number">5.17.</span> <span class="toc-text">
4.17 delete 实现原理？delete 和
delete[] 的区别？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VLN1h"><span class="toc-number">5.18.</span> <span class="toc-text">
4.18 new 和 malloc 的区别，delete
和 free 的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPDZb"><span class="toc-number">5.19.</span> <span class="toc-text">
4.19 malloc 的原理？malloc
的底层实现？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#W7Zzx"><span class="toc-number">5.20.</span> <span class="toc-text">
4.20 C 和 C++ struct
的区别？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bumAM"><span class="toc-number">5.21.</span> <span class="toc-text">
4.21 为什么有了 class 还保留
struct？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#YgTk0"><span class="toc-number">5.22.</span> <span class="toc-text">
4.22 struct 和 union 的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MzTj0"><span class="toc-number">5.23.</span> <span class="toc-text">
4.23 class 和 struct 的异同
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WoREs"><span class="toc-number">5.24.</span> <span class="toc-text">
4.24 volatile
的作用？是否具有原子性，对编译器有什么影响？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#W6tXV"><span class="toc-number">5.25.</span> <span class="toc-text">
4.25 什么情况下一定要用 volatile，
能否和 const 一起使用？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SH2gV"><span class="toc-number">5.26.</span> <span class="toc-text">
4.26
返回函数中静态变量的地址会发生什么？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DUxfn"><span class="toc-number">5.27.</span> <span class="toc-text">
4.27 extern C 的作用？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#W1rH3"><span class="toc-number">5.28.</span> <span class="toc-text">
4.28 sizeof(1&#x3D;&#x3D;1) 在 C 和 C++
中分别是什么结果？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZQ3pL"><span class="toc-number">5.29.</span> <span class="toc-text">
4.29 memcpy 函数的底层原理？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MfFik"><span class="toc-number">5.30.</span> <span class="toc-text">
4.30 strcpy 函数有什么缺陷？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#l0BPq"><span class="toc-number">5.31.</span> <span class="toc-text">
4.31 auto 类型推导的原理
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pYhzb"><span class="toc-number">5.32.</span> <span class="toc-text">
4.32
malloc一次性最大能申请多大内存空间
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ijkBp"><span class="toc-number">5.33.</span> <span class="toc-text">
4.33
public、protected、private的区别
</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#qPsZC"><span class="toc-number">6.</span> <span class="toc-text">
6. 语言特性相关
</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NzBY3"><span class="toc-number">6.1.</span> <span class="toc-text">
6.1
左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rSwk9"><span class="toc-number">6.2.</span> <span class="toc-text">
6.2 std::move()
函数的实现原理
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R7bx2"><span class="toc-number">6.3.</span> <span class="toc-text">
6.3
什么是指针？指针的大小及用法？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#l3Oik"><span class="toc-number">6.4.</span> <span class="toc-text">
6.5 C++ 11 nullptr 比 NULL
优势
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MrE2J"><span class="toc-number">6.5.</span> <span class="toc-text">
6.6 指针和引用的区别？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wsiwb"><span class="toc-number">6.6.</span> <span class="toc-text">
6.7 常量指针和指针常量的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iylg8"><span class="toc-number">6.7.</span> <span class="toc-text">
6.8 函数指针和指针函数的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZKuJI"><span class="toc-number">6.8.</span> <span class="toc-text">
6.9 强制类型转换有哪几种？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#le0Ck"><span class="toc-number">6.9.</span> <span class="toc-text">
6.10 如何判断结构体是否相等？能否用
memcmp 函数判断结构体相等？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#D7IOx"><span class="toc-number">6.10.</span> <span class="toc-text">
6.11
参数传递时，值传递、引用传递、指针传递的区别？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#smt7g"><span class="toc-number">6.11.</span> <span class="toc-text">
6.12 什么是模板？如何实现？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nWycn"><span class="toc-number">6.12.</span> <span class="toc-text">
6.13
函数模板和类模板的区别？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EPJ50"><span class="toc-number">6.13.</span> <span class="toc-text">
6.14 什么是可变参数模板？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wedl8"><span class="toc-number">6.14.</span> <span class="toc-text">
6.15
什么是模板特化？为什么特化？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZiykO"><span class="toc-number">6.15.</span> <span class="toc-text">
6.16 include &quot; &quot; 和 &lt;&gt;
的区别
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a91WF"><span class="toc-number">6.16.</span> <span class="toc-text">
6.17 泛型编程如何实现？
</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ySyMq"><span class="toc-number">6.17.</span> <span class="toc-text">
6.18 C++命名空间
</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Mello13</div><div class="author-info__description text-center">当未来没有来时，它还没有来</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">58</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">24</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">5</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://xyzinc-xyx.github.io/">XYZinc</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://raw.githubusercontent.com/SkylerSuen/PicBase/master/topimg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">mello's blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">C++突击面试</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2024-08-12</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/C/">C++</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/luanfenlian0992/article/details/120022236?spm=1001.2014.3001.5502#618_C_1962"><br>
</a></p>
<h1 id="T78RX">
<font style="color:rgb(79, 79, 79);">1. 编译</font><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a><font style="color:rgb(79, 79, 79);">相关</font>
</h1>
<h2 id="q9dN6">
<font style="color:rgb(79, 79, 79);">1.1. C++ 程序编译过程</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">编译过程分为四个过程：编译（编译预处理、编译、优化），汇编，链接。</font></p>
<ul>
<li><strong><font style="color:rgb(77, 77, 77);">编译预处理</font></strong><font style="color:rgb(77, 77, 77);">：处理以
# 开头的指令；</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">编译、优化</font></strong><font style="color:rgb(77, 77, 77);">：将源码
.cpp 文件翻译成 .s 汇编代码；</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">汇编</font></strong><font style="color:rgb(77, 77, 77);">：将汇编代码
.s 翻译成机器指令 .o 文件；</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">链接</font></strong><font style="color:rgb(77, 77, 77);">：汇编程序生成的目标文件，即
.o 文件，并不会立即执行，因为可能会出现：.cpp 文件中的函数引用了另一个
.cpp文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些文件对应的目标文件连接成一个整体，从而生成可执行的程序
.exe文件。<br>
</font><img src="https://cdn.nlark.com/yuque/0/2022/png/22890233/1662017686760-12978bcc-ffe3-4805-895f-ca74021a1e5c.png"><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">链接分为两种：</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">静态链接</font></strong><font style="color:rgb(77, 77, 77);">：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">动态链接</font></strong><font style="color:rgb(77, 77, 77);">：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</font><font style="color:rgb(77, 77, 77);">二者的优缺点：</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">静态链接</font></strong><font style="color:rgb(77, 77, 77);">：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">动态链接</font></strong><font style="color:rgb(77, 77, 77);">：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要链接，相比静态链接会有一定的性能损失。</font></li>
</ul>
<h2 id="xzGVT">
<font style="color:rgb(79, 79, 79);">1.2.
C++</font><font style="color:rgb(79, 79, 79);"> </font><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86&amp;spm=1001.2101.3001.7020">内存管理</a>
</h2>
<p><font style="color:rgb(77, 77, 77);">C++
内存分区：</font><strong><font style="color:rgb(77, 77, 77);">栈、堆、全局/静态存储区、常量存储区、代码区</font></strong><font style="color:rgb(77, 77, 77);">。</font></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">栈</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。栈从高地址向低地址增长。是一块连续的空间。栈一般分配几M大小的内存。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">堆</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：动态申请的内存空间，就是由
malloc
分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。堆从低地址向高地址增长。一般可以分配几个G大小的内存。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">全局区/静态存储区（.bss
段和 .data
段）</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：存放全局变量和静态变量，程序运行结束操作系统自动释放，在
C 语言中，未初始化的放在.bss 段中，初始化的放在 .data 段中，C++
中不再区分了。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">常量存储区（.data
段</font></strong><font style="color:rgba(0, 0, 0, 0.75);">）：存放的是常量，不允许修改，程序运行结束自动释放。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">代码区（.text
段）</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。</font></li>
</ul>
<h2 id="eODwD">
<font style="color:rgb(79, 79, 79);">1.3. 栈和堆的区别</font>
</h2>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">申请方式</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：栈是系统自动分配，堆是程序员主动申请。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">申请后系统响应</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">申请效率</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">存放的内容</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制。</font></li>
</ul>
<h2 id="mI5WE">
<font style="color:rgb(79, 79, 79);">1.4. 变量的区别</font>
</h2>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&amp;spm=1001.2101.3001.7020">全局变量</a><font style="color:rgb(77, 77, 77);">、局部变量、静态全局变量、静态局部变量的区别：</font></p>
<p><font style="color:rgb(77, 77, 77);">C++
变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为 6
种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">从作用域看：</font></strong></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">全局变量</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern
关键字再次声明这个全局变量。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">静态全局变量</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：具有文件作用域。它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static
关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">局部变量</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：具有局部作用域。它是自动对象（auto），在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">静态局部变量</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：具有局部作用域。它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">从分配内存空间看：</font></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">静态存储区</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：全局变量，静态局部变量，静态全局变量。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">栈</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：局部变量。</font></li>
</ul>
<h2 id="bFKLo">
<font style="color:rgb(79, 79, 79);">1.5.
全局变量定义在头文件中有什么问题？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">如果在头文件中定义全局变量，当该头文件被多个文件
include
时，该头文件中的全局变量就会被定义多次，导致重复定义，因此不能再头文件中定义全局变量。</font></p>
<h2 id="C9VlH">
<font style="color:rgb(79, 79, 79);">1.6. 内存对齐</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">什么是内存对齐？内存对齐的原则？为什么要进行内存对齐，有什么优点？</font></strong></p>
<p><strong><font style="color:rgb(77, 77, 77);">内存对齐</font></strong><font style="color:rgb(77, 77, 77);">：编译器将程序中的每个“数据单元”安排在字的整数倍的地址指向的内存之中<br>
</font><font style="color:rgb(77, 77, 77);">内存对齐的原则：</font></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">结构体每个成员相对于结构体首地址的偏移量
（offset）<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">都是该成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在成员之间加上填充字节
（internal padding）；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing
padding）。</font></li>
</ol>
<p><strong><font style="color:rgb(77, 77, 77);">进行内存对齐的原因</font></strong><font style="color:rgb(77, 77, 77);">：（主要是硬件设备方面的问题）</font></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">某些硬件设备只能存取对齐数据，存取非对齐的数据可能会引发异常；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">某些硬件设备不能保证在存取非对齐数据的时候的操作是原子操作；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">相比于存取对齐的数据，存取非对齐的数据需要花费更多的时间；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">某些处理器虽然支持非对齐数据的访问，但会引发对齐陷阱（alignmenttrap）；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">某些硬件设备只支持简单数据指令非对齐存取，不支持复杂数据指令的非对齐存取。</font></li>
</ol>
<p><strong><font style="color:rgb(77, 77, 77);">内存对齐的优点</font></strong><font style="color:rgb(77, 77, 77);">：</font></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">便于在不同的平台之间进行移植，因为有些硬件平台不能够支持任意地址的数据访问，只能在某些地址处取某些特定的数据，否则会抛出异常；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">提高内存的访问效率，因为
CPU 在读取内存时，是一块一块的读取。</font></li>
</ol>
<h2 id="ST0Qi">
<font style="color:rgb(79, 79, 79);">1.7. 什么是内存泄露</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">内存泄漏：由于疏忽或错误导致的程序未能释放已经不再使用的内存。<br>
</font><font style="color:rgb(77, 77, 77);">进一步解释：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">并非指内存从物理上消失，而是指程序在运行过程中，由于疏忽或错误而失去了对该内存的控制，从而造成了内存的浪费。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">常指堆内存泄漏，因为堆是动态分配的，而且是用户来控制的，如果使用不当，会产生内存泄漏。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">使用
malloc、calloc、realloc、new 等分配内存时，使用完后要调用相应的 free 或
delete释放内存，否则这块内存就会造成内存泄漏。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">指针重新赋值</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line"><span class="type">char</span> *p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line">p = np;</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">开始时，指针 p 和 p1
分别指向一块内存空间，但指针 p 被重新赋值，导致 p
初始时指向的那块内存空间无法找到，从而发生了内存泄漏。</font></p>
<h2 id="qswss">
<font style="color:rgb(79, 79, 79);">1.8.
怎么防止内存泄漏？内存泄漏检测工具的原理？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">防止内存泄漏的方法：</font></strong></p>
<ol type="1">
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">内部封装</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：将内存的分配和释放封装到类中，在构造的时候申请内存，析构的时候释放内存。（说明：但这样做并不是最佳的做法，在类的对象复制时，程序会出现同一块内存空间释放两次的情况）</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">智能指针</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：智能指针是
C++
中已经对内存泄漏封装好了一个工具，可以直接拿来使用，将在下一个问题中对智能指针进行详细的解释。</font></li>
</ol>
<p><strong><font style="color:rgb(77, 77, 77);">VS下内存泄漏的检测方法（CRT）：</font></strong></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">在debug模式下以F5运行：</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CRTDBG_MAP_ALLOC  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;crtdbg.h&gt;</span>   </span></span><br><span class="line"><span class="comment">//在入口函数中包含 _CrtDumpMemoryLeaks();   </span></span><br><span class="line"><span class="comment">//即可检测到内存泄露   </span></span><br><span class="line"><span class="comment">//以如下测试函数为例： </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; 	</span><br><span class="line">    <span class="type">char</span>* pChars = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">CrtDumpMemoryLeaks</span>(); 	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="GNx4c">
<font style="color:rgb(79, 79, 79);">1.9.</font><font style="color:rgb(79, 79, 79);">
</font><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1001.2101.3001.7020">智能指针</a><font style="color:rgb(79, 79, 79);">有哪几种？智能指针的实现原理？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。C++11
中封装在了</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">&lt; memory
&gt;</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">头文件中。</font></p>
<p><font style="color:rgb(77, 77, 77);">C++11
中智能指针包括以下三种：</font></p>
<ul>
<li><strong><font style="color:rgb(77, 77, 77);">共享指针（shared_ptr）</font></strong><font style="color:rgb(77, 77, 77);">：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过
use_count() 查看资源的所有者的个数，可以通过 unique_ptr、weak_ptr
来构造，调用 release() 释放资源的所有权，计数减一，当计数减为 0
时，会自动释放内存空间，从而避免了内存泄漏。</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">独占指针（unique_ptr）</font></strong><font style="color:rgb(77, 77, 77);">：独享所有权的智能指针，资源只能被一个指针占有，该指针不能拷贝构造和赋值。但可以进行移动构造和移动赋值构造（调用move()
函数），即一个 unique_ptr 对象赋值给另一个 unique_ptr
对象，可以通过该方法进行赋值。</font></li>
<li><strong><font style="color:rgb(77, 77, 77);">弱指针（weak_ptr）</font></strong><font style="color:rgb(77, 77, 77);">：指向
shared_ptr
指向的对象，能够解决由shared_ptr带来的循环引用问题。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">智能指针的实现原理：</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">计数原理。</font></p>
<h2 id="gVa2p">
<font style="color:rgb(79, 79, 79);">1.10. 一个 unique_ptr
怎么赋值给另一个 unique_ptr 对象？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">借助</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">std::move()</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">可以实现将一个 unique_ptr
对象赋值给另一个 unique_ptr 对象，其目的是实现所有权的转移。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 作为一个类  </span></span><br><span class="line"><span class="function">std::unique_ptr&lt;A&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> A())</span></span>; </span><br><span class="line">std::unique_ptr&lt;A&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br></pre></td></tr></table></figure>
<h2 id="lBVLR">
<font style="color:rgb(79, 79, 79);">1.11
使用智能指针会出现什么问题？怎么解决？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">智能指针可能出现的问题：循环引用</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">在如下例子中定义了两个类
Parent、Child，在两个类中分别定义另一个类的对象的共享指针，由于在程序结束后，两个指针相互指向对方的内存空间，导致内存无法释放。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">循环引用的解决方法：
weak_ptr</font></strong></p>
<p><strong><font style="color:rgb(77, 77, 77);">循环引用</font></strong><font style="color:rgb(77, 77, 77);">：该被调用的析构函数没有被调用，从而出现了内存泄漏。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">weak_ptr 对被 shared_ptr
管理的对象存在</font><strong><font style="color:rgba(0, 0, 0, 0.75);">非拥有性（弱）引用</font></strong><font style="color:rgba(0, 0, 0, 0.75);">，在访问所引用的对象前必须先转化为
shared_ptr；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">weak_ptr 用来打断
shared_ptr
所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr
引用计数无法抵达
0，内存被泄露；令环中的指针之一为弱指针可以避免该情况；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">weak_ptr
用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用
weak_ptr 跟踪该对象；需要获得所有权时将其转化为
shared_ptr，此时如果原来的 shared_ptr
被销毁，则该对象的生命期被延长至这个临时的 shared_ptr
同样被销毁。</font></li>
</ul>
<h2 id="tLh4C">
<font style="color:rgb(79, 79, 79);">1.12
VS检测内存泄漏，定位泄漏代码位置方法</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">检查方法：<br>
</font><font style="color:rgb(77, 77, 77);">在main函数最后面一行，加上一句</font><font style="color:rgb(77, 77, 77);">_CrtDumpMemoryLeaks()</font><font style="color:rgb(77, 77, 77);">。调试程序，自然关闭程序让其退出（不要定制调试），查看输出：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Detected memory leaks!</span><br><span class="line">Dumping objects -&gt;</span><br><span class="line">&#123;<span class="number">453</span>&#125; normal block at <span class="number">0x02432CA8</span>, <span class="number">868</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;<span class="number">404303374</span>       &gt; <span class="number">34</span> <span class="number">30</span> <span class="number">34</span> <span class="number">33</span> <span class="number">30</span> <span class="number">33</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">&#123;<span class="number">447</span>&#125; normal block at <span class="number">0x024328B0</span>, <span class="number">868</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;<span class="number">404303374</span>       &gt; <span class="number">34</span> <span class="number">30</span> <span class="number">34</span> <span class="number">33</span> <span class="number">30</span> <span class="number">33</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">&#123;<span class="number">441</span>&#125; normal block at <span class="number">0x024324B8</span>, <span class="number">868</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;<span class="number">404303374</span>       &gt; <span class="number">34</span> <span class="number">30</span> <span class="number">34</span> <span class="number">33</span> <span class="number">30</span> <span class="number">33</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">&#123;<span class="number">435</span>&#125; normal block at <span class="number">0x024320C0</span>, <span class="number">868</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;<span class="number">404303374</span>       &gt; <span class="number">34</span> <span class="number">30</span> <span class="number">34</span> <span class="number">33</span> <span class="number">30</span> <span class="number">33</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">&#123;<span class="number">429</span>&#125; normal block at <span class="number">0x02431CC8</span>, <span class="number">868</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;<span class="number">404303374</span>       &gt; <span class="number">34</span> <span class="number">30</span> <span class="number">34</span> <span class="number">33</span> <span class="number">30</span> <span class="number">33</span> <span class="number">33</span> <span class="number">37</span> <span class="number">34</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">&#123;<span class="number">212</span>&#125; normal block at <span class="number">0x01E1BF30</span>, <span class="number">44</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;`               &gt; <span class="number">60</span> B3 E1 <span class="number">01</span> CD CD CD CD CD CD CD CD CD CD CD CD </span><br><span class="line">&#123;<span class="number">204</span>&#125; normal block at <span class="number">0x01E1B2C8</span>, <span class="number">24</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;                &gt; C8 B2 E1 <span class="number">01</span> C8 B2 E1 <span class="number">01</span> C8 B2 E1 <span class="number">01</span> CD CD CD CD </span><br><span class="line">&#123;<span class="number">138</span>&#125; normal block at <span class="number">0x01E15680</span>, <span class="number">332</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;                &gt; <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line">&#123;<span class="number">137</span>&#125; normal block at <span class="number">0x01E15628</span>, <span class="number">24</span> bytes <span class="type">long</span>.</span><br><span class="line"> Data: &lt;(<span class="built_in">V</span>  (<span class="built_in">V</span>  (V      &gt; <span class="number">28</span> <span class="number">56</span> E1 <span class="number">01</span> <span class="number">28</span> <span class="number">56</span> E1 <span class="number">01</span> <span class="number">28</span> <span class="number">56</span> E1 <span class="number">01</span> CD CD CD CD </span><br><span class="line">Object dump complete.</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">取其中一条详细说明：{453} normal
block at 0x02432CA8, 868 bytes long.<br>
</font><font style="color:rgb(77, 77, 77);">被{}包围的453就是我们需要的内存泄漏定位值，868
bytes long就是说这个地方有868比特内存没有释放。<br>
</font><font style="color:rgb(77, 77, 77);">在main函数第一行加上：</font><font style="color:rgb(77, 77, 77);">_CrtSetBreakAlloc(453)</font><font style="color:rgb(77, 77, 77);">;
意思就是在申请453这块内存的位置中断。然后调试程序，……程序中断了。查看调用堆栈</font></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/22890233/1662017686733-f83d40f8-7869-4db3-82e9-86fd3423cd14.png"><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">双击我们的代码调用的最后一个函数，这里是CDbQuery::UpdateDatas()，就定位到了申请内存的代码：<br>
</font><img src="https://cdn.nlark.com/yuque/0/2022/png/22890233/1662017686502-817df84f-02ac-4d7d-b0a0-e0c91d810ec4.png"><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">好了，我们总算知道是哪里出问题了，这块内存没有释放啊。改代码，修复好这个。然后继续…………，直到调试输出中没有normal
block ，程序没有内存泄漏了。</font></p>
<p><font style="color:rgb(77, 77, 77);">记得加上头文件：</font><strong><font style="color:rgb(77, 77, 77);">#include
&lt;crtdbg.h&gt;</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">最后要注意一点的，并不是所有normal
block一定就有内存泄漏，当你的程序中有全局变量的时候，全局变量的释放示在main函数退出后，所以在main函数最后_CrtDumpMemoryLeaks（）会认为全局申请的内存没有释放，造成内存泄漏的假象。如何规避呢？我通常是把全局变量声明成指针在main函数中new
在main函数中delete，然后再调用_CrtDumpMemoryLeaks（），这样就不会误判了。</font></p>
<h2 id="q0vtJ">
<font style="color:rgb(79, 79, 79);">1.13
Linux检测内存泄漏，定位泄漏代码位置方法</font>
</h2>
<h2 id="et1zC">
<font style="color:rgb(79, 79, 79);">1.14 深拷贝与浅拷贝</font>
</h2>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">c++默认的拷贝构造函数是浅拷贝</font></strong><font style="color:rgba(0, 0, 0, 0.75);"><br>
</font><font style="color:rgba(0, 0, 0, 0.75);">浅拷贝就是对象的数据成员之间的简单赋值，如你设计了一个类而没有提供它的复制构造函数，当用该类的一个对象去给令一个对象赋值时所执行的过程就是浅拷贝。当数据成员中没有指针时，浅拷贝是可行的；</font><strong><font style="color:rgba(0, 0, 0, 0.75);">但当数据成员中有指针时，如果采用简单的浅拷贝</font></strong><font style="color:rgba(0, 0, 0, 0.75);">，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">深拷贝与浅拷贝的区别就在于深拷贝会在</font><strong><font style="color:rgba(0, 0, 0, 0.75);">堆内存中另外申请空间来储存数据，而不是一个简单的赋值过程</font></strong><font style="color:rgba(0, 0, 0, 0.75);">，从而也就解决了指针悬挂的问题。</font></li>
</ul>
<h1 id="dYRLc">
<font style="color:rgb(79, 79, 79);">2. 语言对比</font>
</h1>
<h2 id="ZWjBM">
<font style="color:rgb(79, 79, 79);">2.1 C++ 11 新特性</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">1. auto
类型推导</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">auto
关键字：自动类型推导，编译器会在</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">编译期间</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">通过初始值推导出变量的类型，通过
auto 定义的变量必须有初始值。<br>
</font><font style="color:rgb(77, 77, 77);">auto
关键字基本的使用语法如下：</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">2. decltype
类型推导</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">decltype 关键字：decltype
是“declare type”的缩写，译为“声明类型”。和 auto
的功能一样，都用来在编译时期进行自动类型推导。如果希望从表达式中推断出要定义的变量的类型，但是不想用该表达式的值初始化变量，这时就不能再用
auto。decltype 作用是选择并返回操作数的数据类型。</font></p>
<p><font style="color:rgb(77, 77, 77);">区别：</font></p>
<p>auto var = val1 + val2; decltype(val1 + val2) var1 = 0；</p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">auto
根据</font><font style="color:rgba(0, 0, 0, 0.75);">
</font><strong><font style="color:rgba(0, 0, 0, 0.75);">=</font></strong><font style="color:rgba(0, 0, 0, 0.75);">
</font><font style="color:rgba(0, 0, 0, 0.75);">右边的初始值 val1 + val2
推导出变量的类型，并将该初始值赋值给变量 var；decltype 根据 val1 + val2
表达式推导出变量的类型，变量的初始值和与表达式的值无关。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">auto
要求变量必须初始化，因为它是根据初始化的值推导出变量的类型，而 decltype
不要求，定义变量的时候可初始化也可以不初始化。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">3. lambda
表达式</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">lambda 表达式，又被称为
lambda 函数或者 lambda 匿名函数。</font></p>
<p><font style="color:rgb(77, 77, 77);">lambda匿名函数的定义:</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123; function body; &#125;;</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">其中：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">capture list：捕获列表，指
lambda 所在函数中定义的局部变量的列表，通常为空。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">return type、parameter
list、function
body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="type">int</span> arr[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;     <span class="comment">//对 a 数组中的元素进行升序排序     </span></span><br><span class="line">    <span class="built_in">sort</span>(arr, arr+<span class="number">4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );     </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : arr)&#123;         </span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">4. 范围 for
语句</font></strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)&#123; statement &#125; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">参数的含义：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">expression：必须是一个序列，例如用花括号括起来的初始值列表、数组、vector
，string等，这些类型的共同特点是拥有能返回迭代器的 beign、end
成员。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">declaration：此处定义一个变量，序列中的每一个元素都能转化成该变量的类型，常用
auto 类型说明符。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">5.
右值引用</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">右值引用：绑定到右值的引用，用</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">&amp;&amp;</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">来获得右值引用，右值引用只能绑定到要销毁的对象。为了和右值引用区分开，常规的引用称为左值引用。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">42</span>;</span><br><span class="line">    <span class="type">int</span> &amp;l_var = var;</span><br><span class="line">    <span class="type">int</span> &amp;&amp;r_var = var; <span class="comment">// error: cannot bind rvalue reference of type &#x27;int&amp;&amp;&#x27; to lvalue of type &#x27;int&#x27; 错误：不能将右值引用绑定到左值上</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> &amp;&amp;r_var2 = var + <span class="number">40</span>; <span class="comment">// 正确：将 r_var2 绑定到求和结果上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">6. 标准库 move()
函数</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">move()
函数：通过该函数可获得绑定到左值上的右值引用，该函数包括在 utility
头文件中。该知识点会在后续的章节中做详细的说明。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">7.
智能指针</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">相关知识已在第一章中进行了详细的说明，这里不再重复。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">8. delete 函数和 default
函数</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">delete 函数：= delete
表示该函数不能被调用。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">default 函数：= default
表示编译器生成默认的函数，例如：生成默认的构造函数。</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() = <span class="keyword">default</span>; <span class="comment">// 表示使用默认的构造函数</span></span><br><span class="line">	~<span class="built_in">A</span>() = <span class="keyword">default</span>;	<span class="comment">// 表示使用默认的析构函数</span></span><br><span class="line">	<span class="built_in">A</span>(<span class="type">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">// 表示类的对象禁止拷贝构造</span></span><br><span class="line">	A &amp;<span class="keyword">operator</span>=(<span class="type">const</span> A &amp;) = <span class="keyword">delete</span>; <span class="comment">// 表示类的对象禁止拷贝赋值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A ex1;</span><br><span class="line">	A ex2 = ex1; <span class="comment">// error: use of deleted function &#x27;A::A(const A&amp;)&#x27;</span></span><br><span class="line">	A ex3;</span><br><span class="line">	ex3 = ex1; <span class="comment">// error: use of deleted function &#x27;A&amp; A::operator=(const A&amp;)&#x27;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">8. long
long数据类型</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">C++中新定义了long
long，并且规定，一个int至少和一个short一样大，一个long至少和一个int一样大，一个longlong至少和一个long一样大。C++规定了最小尺寸。</font></p>
<h2 id="CHm4T">
<font style="color:rgb(79, 79, 79);">2.2 C 和 C++ 的区别</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">首先说一下面向对象和面向过程：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">面向过程的思路：面向过程编程就是分析出解决问题的步骤，然后把这些步骤一步一步的实现，使用的时候一个一个的依次调用就可以了。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">面向对象的思路：面向对象编程就是把问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">举个例子</font></strong><font style="color:rgb(77, 77, 77);">：（玩五子棋）<br>
</font><font style="color:rgb(77, 77, 77);">（1）用面向过程的思想来考虑就是：开始游戏，白子先走，绘制画面，判断输赢，轮到黑子，绘制画面，判断输赢，重复前面的过程，输出最终结果。<br>
</font><font style="color:rgb(77, 77, 77);">（2）用面向对象的思想来考虑就是：黑白双方（两者的行为是一样的）、棋盘系统（负责绘制画面）、规定系统（规定输赢、犯规等）、输出系统（输出赢家）。<br>
</font><font style="color:rgb(77, 77, 77);">面向对象就是高度实物抽象化（功能划分）、面向过程就是自顶向下的编程（步骤划分）</font></p>
<p><font style="color:rgb(77, 77, 77);">区别和联系：</font></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">C和C++一个典型的区别就在动态内存管理上</font></strong><font style="color:rgba(0, 0, 0, 0.75);">了，C语言通过malloc和free来进行堆内存的分配和释放，而C++是通过new和delete来管理堆内存的；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">强制类型转换上也不一样</font></strong><font style="color:rgba(0, 0, 0, 0.75);">，C的强制类型转换使用()小括号里面加类型进行类型强转的，而C++有四种自己的类型强转方式，分别是const_cast，static_cast，reinterpret_cast和dynamic_cast；</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">C和C++的输入输出方式也不一样</font></strong><font style="color:rgba(0, 0, 0, 0.75);">，printf/scanf，和C++的cout/cin的对别，前面一组是C的库函数，后面是ostream和istream类型的对象。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">C++还支持namespace名字空间，可以让用户自己定义新的名字空间作用域出来，避免全局的名字冲突问题。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">应用领域：C
语言主要用于嵌入式领域，驱动开发等与硬件直接打交道的领域，C++
可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">C++ 既继承了 C
强大的底层操作特性，又被赋予了面向对象机制。它特性繁多，面向对象语言的多继承，对值传递与引用传递的区分以及
const 关键字，等等。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">C++ 对 C
的“增强”，表现在以下几个方面：类型检查更为严格。增加了面向对象的机制、泛型编程的机制（Template）、异常处理、运算符重载、标准模板库（STL）、命名空间（避免全局命名冲突）。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">面向过程语言：</font></p>
<p><strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">优点</font></strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、
Linux/Unix等一般采用面向过程开发，性能是最重要的因素。<br>
</font><strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">缺点</font></strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">：没有面向对象易维护、易复用、易扩展</font></p>
<p><font style="color:rgb(77, 77, 77);">面向对象语言：</font></p>
<p><strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">优点</font></strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统
更加灵活、更加易于维护<br>
</font><strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">缺点</font></strong><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">：性能比面向过程低</font></p>
<h2 id="UiX3k">
<font style="color:rgb(79, 79, 79);">2.3 Python 和 C++ 的区别</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">区别：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">语言自身：Python
为脚本语言，解释执行，不需要经过编译；C++
是一种需要编译后才能运行的语言，在特定的机器上编译后运行。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">运行效率：C++
运行效率高，安全稳定。原因：Python 代码和 C++ 最终都会变成
CPU指令来跑，但一般情况下，比如反转和合并两个字符串，Python
最终转换出来的 CPU 指令会比 C++ 多很多。首先，Python中涉及的内容比 C++
多，经过了更多层，Python 中甚至连数字都是 object ；其次，Python
是解释执行的，和物理机CPU 之间多了解释器这层，而 C++
是编译执行的，直接就是机器码，编译的时候编译器又可以进行一些优化。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">开发效率：Python
开发效率高。原因：Python 一两句代码就能实现的功能，C++
往往需要更多的代码才能实现。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">书写格式和语法不同：Python
的语法格式不同于其 C++
定义声明才能使用，而且极其灵活，完全面向更上层的开发者。</font></li>
</ul>
<h1 id="PoqTH">
<font style="color:rgb(79, 79, 79);">3. 面向对象</font>
</h1>
<h2 id="y64KN">
<font style="color:rgb(79, 79, 79);">3.1
什么是面向对象？面向对象的三大特性</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">面向对象</font></strong><font style="color:rgb(77, 77, 77);">：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</font></p>
<p><font style="color:rgb(77, 77, 77);">面向对象的三大特性：</font></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">封装</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">继承</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：子类继承父类的特征和行为，子类有父类的非
private
方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被
final
关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">多态</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</font></li>
</ul>
<h2 id="InqgD">
<font style="color:rgb(79, 79, 79);">3.2 重载、重写、隐藏的区别</font>
</h2>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">1.重载</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">float</span> tmp)</span></span>;        <span class="comment">// 重载 参数类型不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp, <span class="type">float</span> tmp1)</span></span>; <span class="comment">// 重载 参数个数不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">float</span> tmp, <span class="type">int</span> tmp1)</span></span>; <span class="comment">// 重载 参数顺序不同（相对于上一个函数）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp)</span></span>;            <span class="comment">// error: &#x27;int A::fun(int)&#x27; cannot be overloaded 错误：注意重载不关心函数返回类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">2.隐藏</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp, <span class="type">float</span> tmp1)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp, float tmp1)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun(int tmp)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// 隐藏基类中的同名函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derive ex;</span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>);       <span class="comment">// Derive::fun(int tmp)</span></span><br><span class="line">    ex.<span class="built_in">fun</span>(<span class="number">1</span>, <span class="number">0.01</span>); <span class="comment">// error: candidate expects 1 argument, 2 provided</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">说明</font></strong><font style="color:rgb(77, 77, 77);">：上述代码中
ex.fun(1, 0.01);
出现错误，说明派生类中将基类的同名函数隐藏了。若是想调用基类中的同名函数，可以加上类型名指明
ex.Base::fun(1, 0.01);，这样就可以调用基类中的同名函数。</font></p>
<p><strong><font style="color:rgba(0, 0, 0, 0.75);">3.重写(覆盖)</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有
virtual 修饰。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">    &#125; </span><br><span class="line">; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived::fun(int tmp) : &quot;</span> &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">    &#125; <span class="comment">// 重写基类中的 fun 函数 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derived</span>();     </span><br><span class="line">    p-&gt;<span class="built_in">fun</span>(<span class="number">3</span>); <span class="comment">// Derived::fun(int) : 3     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">重写和重载的区别：</font></strong></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">范围区别</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间（子类和父类之间）。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">参数区别</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有
virtual 修饰。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">virtual
关键字</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：重写的函数基类中必须有
virtual关键字的修饰，重载的函数可以有 virtual
关键字的修饰也可以没有。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">隐藏和重写，重载的区别：</font></strong></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">范围区别</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：隐藏与重载范围不同，隐藏发生在不同类中。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">参数区别</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定相同；当参数不同时，无论基类中的函数是否被
virtual<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">修饰，基类函数都是被隐藏，而不是重写。</font></li>
</ul>
<h2 id="VtIyn">
<font style="color:rgb(79, 79, 79);">3.3 如何理解 C++
是面向对象编程</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">说明：该问题最好结合自己的项目经历进行展开解释，或举一些恰当的例子，同时对比下面向过程编程。</font></p>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">面向过程编程</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：一种以执行程序操作的过程或函数为中心编写软件的方法。程序的数据通常存储在变量中，与这些过程是分开的。所以必须将变量传递给需要使用它们的函数。缺点：随着程序变得越来越复杂，程序数据与运行代码的分离可能会导致问题。例如，程序的规范经常会发生变化，从而需要更改数据的格式或数据结构的设计。当数据结构发生变化时，对数据进行操作的代码也必须更改为接受新的格式。查找需要更改的所有代码会为程序员带来额外的工作，并增加了使代码出现错误的机会。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">面向对象编程（Object-Oriented
Programming,
OOP）</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：以创建和使用对象为中心。一个对象（Object）就是一个软件实体，它将数据和程序在一个单元中组合起来。对象的数据项，也称为其属性，存储在成员变量中。对象执行的过程被称为其成员函数。将对象的数据和过程绑定在一起则被称为封装。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">面向对象编程进一步说明：</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">面向对象编程将数据成员和成员函数封装到一个类中，并声明数据成员和成员函数的访问级别（public、private、protected），以便控制类对象对数据成员和函数的访问，对数据成员起到一定的保护作用。而且在类的对象调用成员函数时，只需知道成员函数的名、参数列表以及返回值类型即可，无需了解其函数的实现原理。当类内部的数据成员或者成员函数发生改变时，不影响类外部的代码。</font></p>
<h2 id="LWI5v">
<font style="color:rgb(79, 79, 79);">3.4
什么是多态？多态如何实现？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">多态</font></strong><font style="color:rgb(77, 77, 77);">：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。在基类的函数前加上
virtual
关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">实现方法</font></strong><font style="color:rgb(77, 77, 77);">：多态是通过虚函数实现的，虚函数的地址保存在虚函数表中，虚函数表的地址保存在含有虚函数的类的实例对象的内存空间中。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">实现过程：</font></strong></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">在类中用 virtual
关键字声明的函数叫做虚函数；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">存在虚函数的类都有一个虚函数表，当创建一个该类的对象时，该对象有一个指向虚函数表的虚表指针（虚函数表和类对应的，虚表指针是和对象对应）；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">当基类指针指向派生类对象，基类指针调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的虚函数。</font></li>
</ol>
<h3 id="EzKGB">
<font style="color:rgb(79, 79, 79);">3.4.1 静态多态与动态多态：</font>
</h3>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">静态多态：也称为编译期间的多态，编译器在编译期间完成的，编译器根据函数实参的类型(可能会进行隐式类型转换)，可推断出要调用那个函数，如果有对应的函数就调用该函数，否则出现编译错误。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">动态多态（动态绑定）：即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法。：<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">●
基类中必须包含虚函数，并且派生类中一定要对基类中的虚函数进行重写。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">●
通过基类对象的指针或者引用调用虚函数。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">	p-&gt;<span class="built_in">fun</span>(); <span class="comment">// Derive::fun() 调用派生类中的虚函数</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">简单解释：当基类的指针指向派生类的对象时，通过派生类的对象的虚表指针找到虚函数表（派生类的对象虚函数表），进而找到相应的虚函数
Derive::f() 进行调用。</font></p>
<h1 id="NRVzM">
<font style="color:rgb(79, 79, 79);">4. 类相关</font>
</h1>
<h2 id="ksfKh">
<font style="color:rgb(79, 79, 79);">5.1
什么是虚函数？什么是纯虚函数？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">虚函数</font></strong><font style="color:rgb(77, 77, 77);">：被
virtual 关键字修饰的成员函数，就是虚函数。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">纯虚函数：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">纯虚函数在类中声明时，加上
=0；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">含有纯虚函数的类称为抽象类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">说明：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">可以声明抽象类指针，可以声明抽象类的引用；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。</font></li>
</ul>
<h2 id="yK7oQ">
<font style="color:rgb(79, 79, 79);">5.2 虚函数和纯虚函数的区别？</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">虚函数和纯虚函数可以出现在同一个类中，该类称为抽象基类。（含有纯虚函数的类称为抽象基类）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">使用方式不同：虚函数可以直接使用，纯虚函数必须在派生类中实现后才能使用；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">定义形式不同：虚函数在定义时在普通函数的基础上加上
virtual 关键字，纯虚函数定义时除了加上virtual 关键字还需要加上
=0;</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">虚函数必须实现，否则编译器会报错；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">对于实现纯虚函数的派生类，该纯虚函数在派生类中被称为虚函数，虚函数和纯虚函数都可以在派生类中重写；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">析构函数最好定义为虚函数，特别是对于含有继承关系的类；析构函数可以定义为纯虚函数，此时，其所在的类为抽象基类，不能创建实例化对象。</font></li>
</ul>
<h2 id="TilFU">
<font style="color:rgb(79, 79, 79);">5.3 虚函数的实现机制</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">实现机制</font></strong><font style="color:rgb(77, 77, 77);">：虚函数通过虚函数表来实现。虚函数的地址保存在虚函数表中，在类的对象所在的内存空间中，保存了指向虚函数表的指针（称为“虚表指针”），通过虚表指针可以找到类对应的虚函数表。虚函数表解决了基类和派生类的继承问题和类中成员函数的覆盖问题，当用基类的指针来操作一个派生类的时候，这张虚函数表就指明了实际应该调用的函数</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">虚函数表相关知识点：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">虚函数表存放的内容：类的虚函数的地址。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">实例：</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">无虚函数覆盖的情况：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">B_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">B_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">B_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base::B_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun1</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun1()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun2</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun2()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">D_fun3</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derive::D_fun3()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base *p = <span class="keyword">new</span> <span class="built_in">Derive</span>();</span><br><span class="line">    p-&gt;<span class="built_in">B_fun1</span>(); <span class="comment">// Base::B_fun1()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">主函数中基类的指针 p
指向了派生类的对象，当调用函数 B_fun1()
时，通过派生类的虚函数表找到该函数的地址，从而完成调用。</font></p>
<h2 id="a8S9D">
<font style="color:rgb(79, 79, 79);">5.4
单继承和多继承的虚函数表结构</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">编译器处理虚函数表：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">如果派生类没有重新定义基类的虚函数
A，则派生类的虚函数表中保存的是基类的虚函数 A
的地址，也就是说基类和派生类的虚函数 A 的地址是一样的。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">如果派生类重写了基类的某个虚函数
B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B
有两个版本，分别存放在基类和派生类的虚函数表中。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">如果派生类重新定义了新的虚函数
C，派生类的虚函数表保存新的虚函数 C 的地址。</font></li>
</ul>
<h2 id="vq17V">
<font style="color:rgb(79, 79, 79);">5.5
为什么构造函数不能为虚函数？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。</font></p>
<h2 id="gqiLq">
<font style="color:rgb(79, 79, 79);">5.6
为什么析构函数可以为虚函数，如果不设为虚函数可能会存在什么问题？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">防止内存泄露，delete
p（基类）的时候，它很机智的先执行了派生类的析构函数，然后执行了基类的析构函数。<br>
</font><font style="color:rgb(77, 77, 77);">如果基类的析构函数不是虚函数，在delete
p（基类）时，调用析构函数时，只会看指针的数据类型，而不会去看赋值的对象，这样就会造成内存泄露。<br>
</font><strong><font style="color:rgb(77, 77, 77);">举例说明：</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">子类B继承自基类A；A <em>p =
new B; delete p;<br>
</em></font><font style="color:rgb(77, 77, 77);">1）
此时，如果类A的析构函数不是虚函数，那么delete
p；将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。<br>
</font><font style="color:rgb(77, 77, 77);">2）
如果类A的析构函数是虚函数，delete p;
将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。<br>
</font><font style="color:rgb(77, 77, 77);">补充： B p = new B;
delete p;时也是先调用B的析构函数，再调用A的析构函数。</font></p>
<h2 id="AeAH2">
<font style="color:rgb(79, 79, 79);">5.7
.不能声明为虚函数的有哪些</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">1、静态成员函数</font></strong><font style="color:rgb(77, 77, 77);">；</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">2、类外的普通函数</font></strong><font style="color:rgb(77, 77, 77);">；</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">3、构造函数</font></strong><font style="color:rgb(77, 77, 77);">；</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">4、友元函数</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">虚函数是为了实现多态特性的。虚函数的调用只有在程序运行的时候才能知道到底调用的是哪个函数，其是有有如下几点需要注意：<br>
</font><font style="color:rgb(77, 77, 77);">（1）
类的</font><strong><font style="color:rgb(77, 77, 77);">构造函数</font></strong><font style="color:rgb(77, 77, 77);">不能是虚函数<br>
</font><font style="color:rgb(77, 77, 77);">构造函数是为了构造对象的，所以在调用构造函数时候必然知道是哪个对象调用了构造函数，所以构造函数不能为虚函数。<br>
</font><font style="color:rgb(77, 77, 77);">（2）
类的</font><strong><font style="color:rgb(77, 77, 77);">静态成员函数</font></strong><font style="color:rgb(77, 77, 77);">不能是虚函数<br>
</font><font style="color:rgb(77, 77, 77);">类的静态成员函数是该类共用的，与该类的对象无关，静态函数里没有this指针，所以不能为虚函数。<br>
</font><font style="color:rgb(77, 77, 77);">（3）</font><strong><font style="color:rgb(77, 77, 77);">内联函数</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">内联函数的目的是为了减少函数调用时间。它是把内联函数的函数体在编译器预处理的时候替换到函数调用处，这样代码运行到这里时候就不需要花时间去调用函数。inline是在编译器将函数类容替换到函数调用处，是静态编译的。而虚函数是动态调用的，在编译器并不知道需要调用的是父类还是子类的虚函数，所以不能够inline声明展开，所以编译器会忽略。<br>
</font><font style="color:rgb(77, 77, 77);">（4）</font><strong><font style="color:rgb(77, 77, 77);">友元函数</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">友元函数与该类无关，没有this指针，所以不能为虚函数。</font></p>
<h1 id="itcw1">
<font style="color:rgb(79, 79, 79);">5. 关键字库函数</font>
</h1>
<h2 id="Z15H9">
<font style="color:rgb(79, 79, 79);">4.1 sizeof 和 strlen 的区别</font>
</h2>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">strlen
是头文件中的函数，sizeof 是 C++ 中的运算符。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">strlen
测量的是字符串的实际长度（其源代码如下），以</font><font style="color:rgba(0, 0, 0, 0.75);">
</font><strong><font style="color:rgba(0, 0, 0, 0.75);">\0</font></strong><font style="color:rgba(0, 0, 0, 0.75);">
</font><font style="color:rgba(0, 0, 0, 0.75);">结束。而 sizeof
测量的是字符数组的分配大小。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//strlen 源代码:</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str++)</span><br><span class="line">        ++length;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font style="color:rgba(0, 0, 0, 0.75);">3.若字符数组 arr
作为函数的形参，sizeof(arr) 中 arr 被当作字符指针来处理，strlen(arr) 中
arr 依然是字符数组，从下述程序的运行结果中就可以看出。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">size_of</span><span class="params">(<span class="type">char</span> arr[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl; <span class="comment">// warning: &#x27;sizeof&#x27; on array function parameter &#x27;arr&#x27; will return size of &#x27;char*&#x27; .</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> arr[<span class="number">20</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">size_of</span>(arr); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">4.strlen
本身是库函数，因此在程序运行过程中，计算长度；而 sizeof
在编译时，计算长度；</font></p>
<p><font style="color:rgb(77, 77, 77);">5.sizeof
的参数可以是类型，也可以是变量；strlen 的参数必须是 char*
类型的变量。</font></p>
<h2 id="Nxflg">
<font style="color:rgb(79, 79, 79);">4.2 lambda
表达式（匿名函数）的具体应用和使用场景</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">lambda
表达式的定义形式如下：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">其中：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">capture list：捕获列表，指
lambda
表达式所在函数中定义的局部变量的列表，通常为空，但如果函数体中用到了
lambda
表达式所在函数的局部变量，必须捕获该变量，即将此变量写在捕获列表中。捕获方式分为：引用捕获方式
[&amp;]、值捕获方式 [=]。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">return type、parameter
list、function
body：分别表示返回值类型、参数列表、函数体，和普通函数一样。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">使用场景一</font></strong><font style="color:rgb(77, 77, 77);">：排序算法</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;     <span class="keyword">return</span> a &gt; b; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="type">int</span> data[<span class="number">6</span>] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">12</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span> &#125;;     </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; testdata;     </span><br><span class="line">    testdata.<span class="built_in">insert</span>(testdata.<span class="built_in">begin</span>(), data, data + <span class="number">6</span>);          <span class="comment">// 排序算法     </span></span><br><span class="line">    <span class="built_in">sort</span>(testdata.<span class="built_in">begin</span>(), testdata.<span class="built_in">end</span>(), compare);    <span class="comment">// 升序 	// 使用lambda表达式 	</span></span><br><span class="line">    <span class="built_in">sort</span>(testdata.<span class="built_in">begin</span>(), testdata.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; <span class="keyword">return</span> a &gt; b; &#125;);     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">使用场景二</font></strong><font style="color:rgb(77, 77, 77);">：排序算法</font></p>
<h2 id="xoF3Y">
<font style="color:rgb(79, 79, 79);">4.3 explicit
的作用（如何避免编译器进行隐式类型转换）</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">作用：用来声明类构造函数是显示调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可用于修饰单参构造函数，因为无参构造函数和多参构造函数本身就是显示调用的，再加上
explicit 关键字也没有什么意义。</font></p>
<p><font style="color:rgb(77, 77, 77);">隐式转换：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="type">int</span> var;     </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> tmp)    &#123;         var = tmp;     &#125; &#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    A ex = <span class="number">10</span>; <span class="comment">// 发生了隐式转换     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">上述代码中，A ex = 10;
在编译时，进行了隐式转换，将 10 转换成 A 类型的对象，然后将该对象赋值给
ex，等同于如下操作：</font></p>
<p><font style="color:rgb(77, 77, 77);">为了避免隐式转换，可用 explicit
关键字进行声明：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="type">int</span> var;     </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">A</span><span class="params">(<span class="type">int</span> tmp)</span></span>&#123;         </span><br><span class="line">        var = tmp;         </span><br><span class="line">        cout &lt;&lt; var &lt;&lt; endl;     &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="function">A <span class="title">ex</span><span class="params">(<span class="number">100</span>)</span></span>;     </span><br><span class="line">    A ex1 = <span class="number">10</span>; <span class="comment">// error: conversion from &#x27;int&#x27; to non-scalar type &#x27;A&#x27; requested     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Vrl3S">
<font style="color:rgb(79, 79, 79);">4.4 C 和 C++ static 的区别</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">在 C 语言中，使用 static
可以定义局部静态变量、外部静态变量、静态函数</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">在 C++ 中，使用 static
可以定义局部静态变量、外部静态变量、静态函数、静态成员变量和静态成员函数。因为
C++中有类的概念，静态成员变量、静态成员函数都是与类有关的概念。</font></li>
</ul>
<h2 id="aW1Z1">
<font style="color:rgb(79, 79, 79);">4.5 static 的作用</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">作用：<br>
</font><font style="color:rgb(77, 77, 77);">static
定义静态变量，静态函数。</font></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">保持变量内容持久：static
作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间。</font></li>
<li><font style="color:rgb(77, 77, 77);">隐藏：static作用于全局变量和函数，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用，在源文件中不具有全局可见性。（注：普通全局变量和函数具有全局可见性，即其他的源文件也可以使用。）</font></li>
<li><font style="color:rgb(77, 77, 77);">static
作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</font></li>
</ul>
<h2 id="d8HpL">
<font style="color:rgb(79, 79, 79);">4.6 static
在类中使用的注意事项（定义、初始化和使用）</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">static 静态成员变量：</font></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">static关键字和private、public、protected
访问规则。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">静态成员变量可以作为成员函数的参数，而普通成员变量不可以。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> s_var;     </span><br><span class="line">    <span class="type">int</span> var;     </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> i = s_var)</span></span>; <span class="comment">// 正确，静态成员变量可以作为成员函数的参数     </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> i = var)</span></span>;   <span class="comment">//  error: invalid use of non-static data member &#x27;A::var&#x27; </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">静态数据成员的类型可以是所属类的类型，而普通数据成员的类型只能是该类类型的指针或引用。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="type">static</span> A s_var; <span class="comment">// 正确，静态数据成员     </span></span><br><span class="line">    A var;          <span class="comment">// error: field &#x27;var&#x27; has incomplete type &#x27;A&#x27;     </span></span><br><span class="line">    A *p;           <span class="comment">// 正确，指针     </span></span><br><span class="line">    A &amp;var1;        <span class="comment">// 正确，引用 </span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">static 静态成员函数：</font></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有
this 指针。静态成员函数做为类作用域的全局函数。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">静态成员函数不能声明成虚函数（virtual）、const
函数和 volatile 函数。</font></li>
</ol>
<h2 id="f5u3W">
<font style="color:rgb(79, 79, 79);">4.7 static
全局变量和普通全局变量的异同</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">相同点：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">存储方式：普通全局变量和
static 全局变量都是静态存储方式。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">不同点：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">作用域：普通全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，普通全局变量在各个源文件中都是有效的；静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">初始化：静态全局变量只初始化一次，防止在其他文件中使用。</font></li>
</ul>
<h2 id="lAxNP">
<font style="color:rgb(79, 79, 79);">4.8 const 作用及用法</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">作用：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">const 修饰成员变量，定义成
const
常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">const
修饰函数参数，使得传递过来的函数参数的值不能改变。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">const
修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable
修饰的变量除外），也不能调用非 const 成员函数，因为非 const
成员函数可能会修改成员变量。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">在类中的用法：</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">const 成员变量：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">const
成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">const
成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的
const 成员变量的值是不同的。因此不能在类的声明中初始化 const
成员变量，类的对象还没有创建，编译器不知道他的值。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">const 成员函数：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">不能修改成员变量的值，除非有
mutable 修饰；只能访问成员变量。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">不能调用非常量成员函数，以防修改成员变量的值。</font></li>
</ul>
<h2 id="UkOea">
<font style="color:rgb(79, 79, 79);">4.9 define 和 const 的区别</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">区别：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">编译阶段：define
是在编译预处理阶段进行替换，const 是在编译阶段确定其值。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">安全性：define
定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const
定义的常量是有类型的，是要进行判断的，可以避免一些低级的错误。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">内存占用：define
定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的空间；const
定义的常量占用静态存储区的空间，程序运行过程中只有一份。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">调试：define
定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；cons定义的常量可以进行调试。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">const 的优点：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">有数据类型，在定义式可进行安全性检查。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">可调式。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">占用较少的空间。</font></li>
</ul>
<h2 id="r6Wcu">
<font style="color:rgb(79, 79, 79);">4.10 define 和 typedef
的区别</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">原理：#define
作为预处理指令，在编译预处理时进行替换操作，不作正确性检查，只有在编译已被展开的源程序时才会发现可能的错误并报错。typedef
是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型一个别名，但不能在一个函数定义里面使用
typedef 。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">功能：typedef
用来定义类型的别名，方便使用。#define
不仅可以为类型取别名，还可以定义常量、变量、编译开关等。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">作用域：#define
没有作用域的限制，只要是之前预定义过的宏，在以后的程序中都可以使用，而
typedef 有自己的作用域。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">指针的操作：typedef 和
#define 在处理指针时不完全一样</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTPTR1 int * </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> * INTPTR2; </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    INTPTR1 p1, p2; <span class="comment">// p1: int *; p2: int     </span></span><br><span class="line">    INTPTR2 p3, p4; <span class="comment">// p3: int *; p4: int *     </span></span><br><span class="line">    <span class="type">int</span> var = <span class="number">1</span>;     </span><br><span class="line">    <span class="type">const</span> INTPTR1 p5 = &amp;var; <span class="comment">// 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。     </span></span><br><span class="line">    <span class="type">const</span> INTPTR2 p6 = &amp;var; <span class="comment">// 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。          </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<h2 id="cyTb5">
<font style="color:rgb(79, 79, 79);">4.11
用宏实现比较大小，以及两个数中的最小值</font>
</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(X, Y) ((X)&gt;(Y)?(X):(Y)) </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(X, Y) ((X)&lt;(Y)?(X):(Y)) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="type">int</span> var1 = <span class="number">10</span>, var2 = <span class="number">100</span>;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(var1, var2) &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">MIN</span>(var1, var2) &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">/* 程序运行结果： 100 10 */</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="mpIbM">
<font style="color:rgb(79, 79, 79);">4.12 inline 作用及使用方法</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">作用：</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">inline
是一个关键字，可以用于定义内联函数。内联函数，像普通函数一样被调用，但是在调用时并不通过函数调用的机制而是直接在调用点处展开，这样可以大大减少由函数调用带来的开销，从而提高程序的运行效率。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">使用方法：</font></strong></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">类内定义成员函数默认是内联函数<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">在类内定义成员函数，可以不用在函数头部加
inline
关键字，因为编译器会自动将类内定义的函数（构造函数、析构函数、普通成员函数等）声明为内联函数，代码如下：</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line"><span class="type">int</span> var;     </span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> tmp)&#123;        var = tmp;     &#125;         </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;          cout &lt;&lt; var &lt;&lt; endl;     &#125; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">类外定义成员函数，若想定义为内联函数，需用关键字声明<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">当在类内声明函数，在类外定义函数时，如果想将该函数定义为内联函数，则可以在类内声明时不加
inline 关键字，而在类外定义函数时加上 inline 关键字。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line"><span class="type">int</span> var;     </span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> tmp)&#123;        var = tmp;     &#125;         </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::fun</span><span class="params">()</span></span>&#123;     cout &lt;&lt; var &lt;&lt; endl; &#125; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">另外，可以在声明函数和定义函数的同时加上
inline；也可以只在函数声明时加 inline，而定义函数时不加
inline。只要确保在调用该函数之前把 inline
的信息告知编译器即可。</font></p>
<h2 id="N1ic8">
<font style="color:rgb(79, 79, 79);">4.13 inline 函数工作原理</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">内联函数不是在调用时发生控制转移关系，而是在编译阶段将函数体嵌入到每一个调用该函数的语句块中，编译器会将程序中出现内联函数的调用表达式用内联函数的函数体来替换。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">普通函数是将程序执行转移到被调用函数所存放的内存地址，当函数执行完后，返回到执行此函数前的地方。转移操作需要保护现场，被调函数执行完后，再恢复现场，该过程需要较大的资源开销。</font></li>
</ul>
<h2 id="RXyWh">
<font style="color:rgb(79, 79, 79);">4.14
宏定义（define）和内联函数（inline）的区别</font>
</h2>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">内联函数是在编译时展开，而宏在编译预处理时展开；在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">内联函数是真正的函数，和普通函数调用的方法一样，在调用点处直接展开，避免了函数的参数压栈操作，减少了调用的开销。而宏定义编写较为复杂，常需要增加一些括号来避免歧义。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">宏定义只进行文本替换，不会对参数的类型、语句能否正常编译等进行检查。而内联函数是真正的函数，会对参数的类型、函数体内的语句编写是否正确等进行检查。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b)) </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">fun_max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;     <span class="keyword">return</span> a &gt; b ? a : b; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="type">int</span> var = <span class="number">1</span>;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">MAX</span>(var, <span class="number">5</span>) &lt;&lt; endl;          </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_max</span>(var, <span class="number">0</span>) &lt;&lt; endl;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">/* 程序运行结果： 5 1 */</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ar9ec">
<font style="color:rgb(79, 79, 79);">4.15 new 的作用？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">new 是 C++
中的关键字，用来动态分配内存空间，实现方式如下：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];  </span><br></pre></td></tr></table></figure>
<h2 id="v0ORN">
<font style="color:rgb(79, 79, 79);">4.16 new 和 malloc
如何判断是否申请到内存？</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">malloc
：成功申请到内存，返回指向该内存的指针；分配失败，返回 NULL
指针。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">new
：内存分配成功，返回该对象类型的指针；分配失败，抛出 bac_alloc
异常。</font></li>
</ul>
<h2 id="BMJ7Q">
<font style="color:rgb(79, 79, 79);">4.17 delete 实现原理？delete 和
delete[] 的区别？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">delete
的实现原理：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">首先执行该对象所属类的析构函数；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">进而通过调用 operator
delete 的标准库函数来释放所占的内存空间。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">delete 和 delete []
的区别：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">delete
用来释放单个对象所占的空间，只会调用一次析构函数；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">delete []
用来释放数组空间，会对数组中的每个成员都调用一次析构函数。</font></li>
</ul>
<h2 id="VLN1h">
<font style="color:rgb(79, 79, 79);">4.18 new 和 malloc 的区别，delete
和 free 的区别</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">在使用的时候 new、delete
搭配使用，malloc、free 搭配使用。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">malloc、free
是库函数，而new、delete 是关键字。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">new
申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc
在申请空间时，需要确定所申请空间的大小。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">new
申请空间时，返回的类型是对象的指针类型，无需强制类型转换，是类型安全的操作符；malloc
申请空间时，返回的是 void*
类型，需要进行强制类型的转换，转换为对象类型的指针。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">new 分配失败时，会抛出
bad_alloc 异常，malloc 分配失败时返回空指针。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">对于自定义的类型，new
首先调用 operator new() 函数申请空间（底层通过 malloc
实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete
首先调用析构函数，然后调用 operator delete() 释放空间（底层通过 free
实现）。malloc、free 无法进行自定义类型的对象的构造和析构。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">new
操作符从自由存储区上为对象动态分配内存，而 malloc
函数从堆上动态分配内存。（自由存储区不等于堆）</font></li>
</ul>
<h2 id="GPDZb">
<font style="color:rgb(79, 79, 79);">4.19 malloc 的原理？malloc
的底层实现？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">malloc
的原理:</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">当开辟的空间小于 128K
时，调用 brk() 函数，通过移动 _enddata 来实现；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">当开辟空间大于 128K
时，调用 mmap()
函数，通过在虚拟地址空间中开辟一块内存空间来实现。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">malloc
的底层实现：</font></strong></p>
<ul>
<li><font style="color:rgb(77, 77, 77);">brk()
函数实现原理：向高地址的方向移动指向数据段的高地址的指针
_enddata。</font></li>
<li><font style="color:rgb(77, 77, 77);">mmap 内存映射原理：<br>
</font><font style="color:rgb(77, 77, 77);">1.进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域；<br>
</font><font style="color:rgb(77, 77, 77);">2.调用内核空间的系统调用函数
mmap()，实现文件物理地址和进程虚拟地址的一一映射关系；<br>
</font><font style="color:rgb(77, 77, 77);">3.进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝。</font></li>
</ul>
<h2 id="W7Zzx">
<font style="color:rgb(79, 79, 79);">4.20 C 和 C++ struct
的区别？</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">在 C 语言中 struct
是用户自定义数据类型；在 C++ 中 struct
是抽象数据类型，支持成员函数的定义。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">C 语言中 struct
没有访问权限的设置，是一些变量的集合体，不能定义成员函数；C++ 中 struct
可以和类一样，有访问权限，并可以定义成员函数。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">C 语言中 struct
定义的自定义数据类型，在定义该类型的变量时，需要加上 struct
关键字，例如：struct A var;，定义 A 类型的变量；而 C++
中，不用加该关键字，例如：A var;</font></li>
</ul>
<h2 id="bumAM">
<font style="color:rgb(79, 79, 79);">4.21 为什么有了 class 还保留
struct？</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">C++ 是在 C
语言的基础上发展起来的，为了与 C 语言兼容，C++ 中保留了
struct。</font></li>
</ul>
<h2 id="YgTk0">
<font style="color:rgb(79, 79, 79);">4.22 struct 和 union 的区别</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">说明：union 是联合体，struct
是结构体。</font></p>
<p><font style="color:rgb(77, 77, 77);">区别：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">联合体和结构体都是由若干个数据类型不同的数据成员组成。使用时，联合体只有一个有效的成员；而结构体所有的成员都有效。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">对联合体的不同成员赋值，将会对覆盖其他成员的值，而对于结构体的对不同成员赋值时，相互不影响。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小；结构体分配内存的大小遵循内存对齐原则。</font></li>
</ul>
<h2 id="MzTj0">
<font style="color:rgb(79, 79, 79);">4.23 class 和 struct 的异同</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">struct 和 class
都可以自定义数据类型，也支持继承操作。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">struct 中默认的访问级别是
public，默认的继承级别也是 public；class 中默认的访问级别是
private，默认的继承级别也是 private。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">当 class 继承 struct 或者
struct 继承 class 时，默认的继承级别取决于 class 或 struct
本身，class（private 继承），struct（public
继承），即取决于派生类的默认继承级别。</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span>&#123;&#125;； </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : A&#123;&#125;; <span class="comment">// private 继承  </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span> : B&#123;&#125;； <span class="comment">// public 继承 123</span></span><br></pre></td></tr></table></figure>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">class
可以用于定义模板参数，struct 不能用于定义模板参数。</font></li>
</ul>
<h2 id="WoREs">
<font style="color:rgb(79, 79, 79);">4.24 volatile
的作用？是否具有原子性，对编译器有什么影响？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">volatile
的作用</font></strong><font style="color:rgb(77, 77, 77);">：当对象的值可能在程序的控制或检测之外被改变时，应该将该对象声明为
violatile，告知编译器不应对这样的对象进行优化。</font></p>
<p><font style="color:rgb(77, 77, 77);">volatile不具有原子性。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">volatile
对编译器的影响</font></strong><font style="color:rgb(77, 77, 77);">：使用该关键字后，编译器不会对相应的对象进行优化，即不会将变量从内存缓存到寄存器中，防止多个线程有可能使用内存中的变量，有可能使用寄存器中的变量，从而导致程序错误。</font></p>
<h2 id="W6tXV">
<font style="color:rgb(79, 79, 79);">4.25 什么情况下一定要用 volatile，
能否和 const 一起使用？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">使用 volatile
关键字的场景：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">当多个线程都会用到某一变量，并且该变量的值有可能发生改变时，需要用
volatile 关键字对该变量进行修饰；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">中断服务程序中访问的变量或并行设备的硬件寄存器的变量，最好用
volatile 关键字修饰。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">volatile 关键字和 const
关键字可以同时使用，某种类型可以既是 volatile 又是 const
，同时具有二者的属性。</font></p>
<h2 id="SH2gV">
<font style="color:rgb(79, 79, 79);">4.26
返回函数中静态变量的地址会发生什么？</font>
</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> * <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp)</span></span>&#123;     </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> var = <span class="number">10</span>;     </span><br><span class="line">    var *= tmp;     </span><br><span class="line">    <span class="keyword">return</span> &amp;var; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    cout &lt;&lt; *<span class="built_in">fun</span>(<span class="number">5</span>) &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">/* 运行结果： 50 */</span> </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">说明：上述代码中在函数 fun
中定义了静态局部变量
var，使得离开该函数的作用域后，该变量不会销毁，返回到主函数中，该变量依然存在，从而使程序得到正确的运行结果。但是，该静态局部变量直到程序运行结束后才销毁，浪费内存空间。</font></p>
<h2 id="DUxfn">
<font style="color:rgb(79, 79, 79);">4.27 extern C 的作用？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">extern
"C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern
"C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。<br>
</font><font style="color:rgb(77, 77, 77);">举例：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能出现在 C++ 头文件&lt;cstring&gt;中的链接指示 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;     <span class="function"><span class="type">int</span> <span class="title">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>*, <span class="type">const</span> <span class="type">char</span>*)</span></span>; &#125; <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="W1rH3">
<font style="color:rgb(79, 79, 79);">4.28 sizeof(1==1) 在 C 和 C++
中分别是什么结果？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">C 语言代码：4</font></p>
<p><font style="color:rgb(77, 77, 77);">C++ 代码：1</font></p>
<h2 id="ZQ3pL">
<font style="color:rgb(79, 79, 79);">4.29 memcpy 函数的底层原理？</font>
</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dst, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> size)</span> </span>&#123;     </span><br><span class="line">    <span class="type">char</span> *psrc;     </span><br><span class="line">    <span class="type">char</span> *pdst;     </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == dst || <span class="literal">NULL</span> == src)     &#123;         <span class="keyword">return</span> <span class="literal">NULL</span>;     &#125;     </span><br><span class="line">    <span class="keyword">if</span> ((src &lt; dst) &amp;&amp; (<span class="type">char</span> *)src + size &gt; (<span class="type">char</span> *)dst) <span class="comment">// 出现地址重叠的情况，自后向前拷贝    </span></span><br><span class="line">    &#123;         psrc = (<span class="type">char</span> *)src + size - <span class="number">1</span>;         </span><br><span class="line">              pdst = (<span class="type">char</span> *)dst + size - <span class="number">1</span>;         </span><br><span class="line">              <span class="keyword">while</span> (size--)         &#123;             *pdst-- = *psrc--;         &#125;     </span><br><span class="line">    &#125;     <span class="keyword">else</span>     &#123;         </span><br><span class="line">        psrc = (<span class="type">char</span> *)src;         </span><br><span class="line">        pdst = (<span class="type">char</span> *)dst;         </span><br><span class="line">        <span class="keyword">while</span> (size--)         &#123;             *pdst++ = *psrc++;         &#125;     &#125;     </span><br><span class="line">    <span class="keyword">return</span> dst; &#125; </span><br></pre></td></tr></table></figure>
<h2 id="MfFik">
<font style="color:rgb(79, 79, 79);">4.30 strcpy 函数有什么缺陷？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">strcpy 函数的缺陷：strcpy
函数不检查目的缓冲区的大小边界，而是将源字符串逐一的全部赋值给目的字符串地址起始的一块连续的内存空间，同时加上字符串终止符，会导致其他变量被覆盖。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">说明</font></strong><font style="color:rgb(77, 77, 77);">：从上述代码中可以看出，变量
var 的后六位被字符串 “hello world!” 的 “d!\0”
这三个字符改变，这三个字符对应的 ascii
码的十六进制为：\0(0x00)，!(0x21)，d(0x64)。<br>
</font><strong><font style="color:rgb(77, 77, 77);">原因</font></strong><font style="color:rgb(77, 77, 77);">：变量
arr 只分配的 10 个内存空间，通过上述程序中的地址可以看出 arr 和 var
在内存中是连续存放的，但是在调用 strcpy 函数进行拷贝时，源字符串 “hello
world!” 所占的内存空间为 13，因此在拷贝的过程中会占用 var
的内存空间，导致 var的后六位被覆盖。</font></p>
<h2 id="l0BPq">
<font style="color:rgb(79, 79, 79);">4.31 auto 类型推导的原理</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">auto
类型推导的原理：</font></strong></p>
<p><font style="color:rgb(77, 77, 77);">编译器根据初始值来推算变量的类型，要求用
auto 定义变量时必须有初始值。编译器推断出来的 auto
类型有时和初始值类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。</font></p>
<h2 id="pYhzb">
<font style="color:rgb(79, 79, 79);">4.32
malloc一次性最大能申请多大内存空间</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">malloc并不是系统调用。因此并不是内存空间的终极管理者。最大能够申请多大空间，并不是malloc一个人能说了算的。<br>
</font><font style="color:rgb(77, 77, 77);">malloc有多种实现，不同的实现有不同的特点。一般情况下，malloc是从系统获取内存分页，然后将这些分页组织为不同大小的“块”。当用户程序申请内存的时候，如果大小没有超过“块”的大小，则malloc在内部匹配尺寸最为接近的，不小于申请的尺寸的块，记录分配信息之后，返回地址。这样做的目的是加快分配的速度，减少系统调用。<br>
</font><font style="color:rgb(77, 77, 77);">如果申请的空间很大，则malloc会直接向系统申请多个分页，将其map到用户程序的虚拟地址空间当中的一个连续的区间（这个同样是系统调用），然后返回地址。</font></p>
<p><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">分页的管理，是由操作系统完成的。现代操作系统大多支持虚拟内存，也就是不仅仅使用RAM，还使用磁盘上的交换文件作为内存空间。操作系统将这些空间按照一定大小切分成页，在一个被称为是页表的结构当中进行维护。操作系统级别的内存管理，都是以页为单位的。<br>
</font><font style="color:rgb(85, 86, 102);background-color:rgb(238, 240, 244);">页的实际存储位置由操作系统管理。当多个应用程序同时执行时，操作系统会将不活动的页从RAM当中移动到磁盘文件当中。当应用程序重新尝试访问该页的时候，再从磁盘文件读入到RAM当中，这个称为页交换。</font></p>
<p><font style="color:rgb(77, 77, 77);">也是因为页的这个特性，操作系统完全可以分配实际上不存在的页给malloc，直到该页被真正使用。所以说理论上malloc
1TB可能都没有问题，虽然RAM和磁盘上的交换文件（或者交换分区）加起来往往也就是几十个GB。这就是因为操作系统实际上并没有分配完整的空间给这些页，只是在页表当中记了一笔：A程序需要XXXX页，并留出相应的行，在其中记录“未确保空间”。</font></p>
<p><font style="color:rgb(77, 77, 77);">当应用程序真的开始尝试对malloc返回的地址进行读写的时候，如果操作系统检测到页其实还没有分配实际的空间，这个时候才会去寻找合适的空间填写进页表。如果找不到合适的空间，那么就会触发页错误（overcommit错误）。</font></p>
<p><font style="color:rgb(77, 77, 77);">在Linux当中，我们是可以关闭overcommit功能，要求操作系统每次分配分页的时候都确保分页可用，那么malloc可分配的最大大小就受</font><strong><font style="color:rgb(77, 77, 77);">实际RAM+交换文件/分区大小的限制</font></strong><font style="color:rgb(77, 77, 77);">。在Linux当中，为保障操作系统自身的运行，通常这个大小是RAM的一半+交换区的大小。（当然可改变设置）。</font></p>
<p><font style="color:rgb(77, 77, 77);">另外，单次可分配的大小和多次合计可分配的大小也不是同一个概念，因为多次分配存在内存碎片化的问题。就好像一个饭店虽然有40个座位，但是也许只需要几个人你就没办法找到一张8人桌一样。</font></p>
<p><font style="color:rgb(77, 77, 77);">所以，在当代操作系统当中，malloc可以分配的空间的最大大小，首先当然受</font><strong><font style="color:rgb(77, 77, 77);">机器的bit数</font></strong><font style="color:rgb(77, 77, 77);">，也就是可以直接寻址的空间大小制约；在这个基础上进一步受</font><strong><font style="color:rgb(77, 77, 77);">操作系统的策略制约</font></strong><font style="color:rgb(77, 77, 77);">；然后受</font><strong><font style="color:rgb(77, 77, 77);">实际可用资源量的制约</font></strong><font style="color:rgb(77, 77, 77);">；再者还受</font><strong><font style="color:rgb(77, 77, 77);">malloc本身算法的制约</font></strong><font style="color:rgb(77, 77, 77);">；最后还受</font><strong><font style="color:rgb(77, 77, 77);">应用程序申请方式和次数的制约</font></strong><font style="color:rgb(77, 77, 77);">。</font></p>
<h2 id="ijkBp">
<font style="color:rgb(79, 79, 79);">4.33
public、protected、private的区别</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">第一:
private,public,protected的访问范围：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">private:
只能由该类中的函数、其友元函数访问，不能被任何其他访问，该类的对象也不能访问</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">protected:
可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">public:
可以被该类中的函数、子类的函数、其友元函数访问，也可以由该类的对象访问</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">第二:类的继承后方法属性变化:</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">使用private继承，父类的所有方法在子类中变为private;</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">使用protected继承，父类的protected和public方法在子类中变为protected，而private方法不变;</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">使用public继承，父类中的方法属性不发生改变;</font></li>
</ul>
<h1 id="qPsZC">
<font style="color:rgb(79, 79, 79);">6. 语言特性相关</font>
</h1>
<h2 id="NzBY3">
<font style="color:rgb(79, 79, 79);">6.1
左值和右值的区别？左值引用和右值引用的区别，如何将左值转换成右值？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">左值：指表达式结束后依然存在的持久对象。</font></p>
<p><font style="color:rgb(77, 77, 77);">右值：表达式结束就不再存在的临时对象。</font></p>
<p><font style="color:rgb(77, 77, 77);">左值和右值的区别：左值持久，右值短暂</font></p>
<p><font style="color:rgb(77, 77, 77);">右值引用和左值引用的区别：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式，但不能绑定到一个左值上。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">右值引用必须绑定到右值的引用，通过</font><font style="color:rgba(0, 0, 0, 0.75);">
</font><strong><font style="color:rgba(0, 0, 0, 0.75);">&amp;&amp;</font></strong><font style="color:rgba(0, 0, 0, 0.75);">
</font><font style="color:rgba(0, 0, 0, 0.75);">获得。右值引用只能绑定到一个将要销毁的对象上，因此可以自由地移动其资源。</font></li>
</ul>
<p><strong><font style="color:rgb(77, 77, 77);">std::move</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">可以将一个左值强制转化为右值，继而可以通过右值引用使用该值，以用于移动语义。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span>&amp; tmp)</span>  </span>&#123;    cout &lt;&lt; <span class="string">&quot;fun1(int&amp; tmp):&quot;</span> &lt;&lt; tmp &lt;&lt; endl;  &#125;  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span>&amp;&amp; tmp)</span>  </span>&#123;    cout &lt;&lt; <span class="string">&quot;fun2(int&amp;&amp; tmp)&quot;</span> &lt;&lt; tmp &lt;&lt; endl;  &#125;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;    </span><br><span class="line">    <span class="type">int</span> var = <span class="number">11</span>;    </span><br><span class="line">    <span class="built_in">fun1</span>(<span class="number">12</span>); <span class="comment">// error: cannot bind non-const lvalue reference of type &#x27;int&amp;&#x27; to an rvalue of type &#x27;int&#x27;   </span></span><br><span class="line">    <span class="built_in">fun1</span>(var);   </span><br><span class="line">    <span class="built_in">fun2</span>(<span class="number">1</span>);  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="rSwk9">
<font style="color:rgb(79, 79, 79);">6.2 std::move()
函数的实现原理</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">std::move()</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">函数原型：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; </span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(T&amp;&amp; t)</span> </span></span><br><span class="line"><span class="function"></span>&#123; 	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t); &#125; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">说明：引用折叠原理</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">右值传递给上述函数的形参
T&amp;&amp; 依然是右值，即 T&amp;&amp; &amp;&amp; 相当于
T&amp;&amp;。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">左值传递给上述函数的形参
T&amp;&amp; 依然是左值，即 T&amp;&amp; &amp; 相当于 T&amp;。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">小结：通过引用折叠原理可以知道，move()
函数的形参既可以是左值也可以是右值。</font></p>
<p><strong><font style="color:rgb(77, 77, 77);">remove_reference</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">具体实现：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始的，最通用的版本 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">remove_reference</span>&#123;     </span><br><span class="line"><span class="keyword">typedef</span> T type;  <span class="comment">//定义 T 的类型别名为 type </span></span><br><span class="line">&#125;;   <span class="comment">//部分版本特例化，将用于左值引用和右值引用 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&gt; <span class="comment">//左值引用 </span></span><br><span class="line">&#123; <span class="keyword">typedef</span> T type; &#125;   </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">struct</span> <span class="title class_">remove_reference</span>&lt;T&amp;&amp;&gt; <span class="comment">//右值引用 </span></span><br><span class="line">&#123; <span class="keyword">typedef</span> T type; &#125;       <span class="comment">//举例如下,下列定义的a、b、c三个变量都是int类型 </span></span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;             <span class="comment">//使用原版本， </span></span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(i)&gt;::type  b;             <span class="comment">//左值引用特例版本 </span></span><br><span class="line">remove_refrence&lt;<span class="keyword">decltype</span>(std::<span class="built_in">move</span>(i))&gt;::type  b;  <span class="comment">//右值引用特例版本  </span></span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">举例：</font></p>
<p>int var = 10;</p>
<p>转化过程： 1. std::move(var) =&gt; std::move(int&amp;&amp; &amp;)
=&gt; 折叠后 std::move(int&amp;)</p>
<ol start="2" type="1">
<li><p>此时：T 的类型为 int&amp;，typename remove_reference<T>::type 为
int，这里使用 remove_reference 的左值引用的特例化版本</T></p></li>
<li><p>通过 static_cast 将 int&amp; 强制转换为 int&amp;&amp;</p></li>
</ol>
<p>整个std::move被实例化如下：</p>
<p>string&amp;&amp; move(int&amp; t) {</p>
<p>return static_cast&lt;int&amp;&amp;&gt;(t);</p>
<p>}</p>
<p><font style="color:rgb(77, 77, 77);">总结：<br>
</font><font style="color:rgb(77, 77, 77);">std::move()
实现原理：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">利用引用折叠原理将右值经过
T&amp;&amp; 传递类型保持不变还是右值，而左值经过 T&amp;&amp;<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">变为普通的左值引用，以保证模板可以传递任意实参，且保持类型不变；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">然后通过 remove_refrence
移除引用，得到具体的类型 T；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">最后通过
static_cast&lt;&gt; 进行强制类型转换，返回 T&amp;&amp;
右值引用。</font></li>
</ul>
<h2 id="R7bx2">
<font style="color:rgb(79, 79, 79);">6.3
什么是指针？指针的大小及用法？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">指针</font></strong><font style="color:rgb(77, 77, 77);">：
指向另外一种类型的复合类型。<br>
</font><strong><font style="color:rgb(77, 77, 77);">指针的大小</font></strong><font style="color:rgb(77, 77, 77);">：
在 64 位计算机中，指针占 8 个字节空间。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> using namespace std; </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> *p = <span class="literal">nullptr</span>;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl; <span class="comment">// 8     </span></span><br><span class="line">    <span class="type">char</span> *p1 = <span class="literal">nullptr</span>;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(p1) &lt;&lt; endl; <span class="comment">// 8     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(152, 195, 121);background-color:rgb(40, 44, 52);"></font></p>
<p><font style="color:rgb(77, 77, 77);">指针的用法：</font></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">指向普通对象的指针</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; &#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>();     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">指向常量对象的指针：常量指针</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_var = <span class="number">10</span>;     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * p = &amp;c_var;     </span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">指向函数的指针：函数指针</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;     <span class="keyword">return</span> a + b; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;     </span><br><span class="line">    <span class="built_in">int</span> (*fun_p)(<span class="type">int</span>, <span class="type">int</span>);     </span><br><span class="line">    fun_p = add;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun_p</span>(<span class="number">1</span>, <span class="number">6</span>) &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">指向对象成员的指针，包括指向对象成员函数的指针和指向对象成员变量的指针。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">特别注意：定义指向成员函数的指针时，要标明指针所属的类。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     <span class="type">int</span> var1, var2;      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;         </span><br><span class="line">    <span class="keyword">return</span> var1 + var2;     &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    A ex;     </span><br><span class="line">    ex.var1 = <span class="number">3</span>;     </span><br><span class="line">    ex.var2 = <span class="number">4</span>;     </span><br><span class="line">    <span class="type">int</span> *p = &amp;ex.var1; <span class="comment">// 指向对象成员变量的指针     </span></span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;     </span><br><span class="line">    <span class="built_in">int</span> (A::*fun_p)();     </span><br><span class="line">    fun_p = A::add; <span class="comment">// 指向对象成员函数的指针 fun_p     </span></span><br><span class="line">    cout &lt;&lt; (ex.*fun_p)() &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">this
指针：指向类的当前对象的指针常量。</font></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_name</span><span class="params">(string tmp)</span></span>&#123;         </span><br><span class="line">    <span class="keyword">this</span>-&gt;name = tmp;     </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_age</span><span class="params">(<span class="type">int</span> tmp)</span></span>&#123;         </span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;     </span><br><span class="line"> &#125;     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_sex</span><span class="params">(<span class="type">int</span> tmp)</span></span>&#123;         </span><br><span class="line">    <span class="keyword">this</span>-&gt;sex = tmp;     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;         </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; endl;         </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; endl;         </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Sex: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;sex &lt;&lt; endl;     </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">private</span>:     </span><br><span class="line">    string name;     </span><br><span class="line">    <span class="type">int</span> age;     </span><br><span class="line">    <span class="type">int</span> sex; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    A *p = <span class="keyword">new</span> <span class="built_in">A</span>();     </span><br><span class="line">    p-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;Alice&quot;</span>);     </span><br><span class="line">    p-&gt;<span class="built_in">set_age</span>(<span class="number">16</span>);    </span><br><span class="line">    p-&gt;<span class="built_in">set_sex</span>(<span class="number">1</span>);    </span><br><span class="line">    p-&gt;<span class="built_in">show</span>();     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">什么是野指针和悬空指针？<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">悬空指针：</font></li>
</ol>
<p><font style="color:rgb(77, 77, 77);">若指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存空间，此时，称该指针为“悬空指针”。</font></p>
<p>void *p = malloc(size); free(p); // 此时，p 指向的内存空间已释放， p
就是悬空指针。</p>
<p><font style="color:rgb(77, 77, 77);">野指针：</font></p>
<p>“野指针”是指不确定其指向的指针，未初始化的指针为“野指针”。</p>
<p>void *p; // 此时 p 是“野指针”。</p>
<h2 id="l3Oik">
<font style="color:rgb(79, 79, 79);">6.5 C++ 11 nullptr 比 NULL
优势</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">NULL：预处理变量，是一个宏，它的值是
0，定义在头文件 中，即 #define NULL 0。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">nullptr：C++ 11
中的关键字，是一种特殊类型的字面值，可以被转换成任意其他类型。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">nullptr 的优势：</font></p>
<ol type="1">
<li><font style="color:rgba(0, 0, 0, 0.75);">有类型，类型是 typdef
decltype(nullptr) nullptr_t;，使用 nullptr
提高代码的健壮性。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">函数重载：因为 NULL
本质上是 0，在函数调用过程中，若出现函数重载并且传递的实参是
NULL，可能会出现，不知和哪一个函数匹配的情况；但是传递实参 nullptr
就不会出现这种情况。</font></li>
</ol>
<h2 id="MrE2J">
<font style="color:rgb(79, 79, 79);">6.6 指针和引用的区别？</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间。（是否占内存）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">指针可以为空，但是引用必须绑定对象。（是否可为空）</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">指针可以有多级，但是引用只能一级。（是否能为多级）</font></li>
</ul>
<h2 id="Wsiwb">
<font style="color:rgb(79, 79, 79);">6.7 常量指针和指针常量的区别</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">常量指针：</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">常量指针本质上是个指针，只不过这个指针指向的对象是常量。<br>
</font><strong><font style="color:rgb(77, 77, 77);">特点</font></strong><font style="color:rgb(77, 77, 77);">：const
的位置在指针声明运算符 * 的左侧。只要 const 位于 *
的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。（可以这样理解，*
左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。）</font></p>
<p>const int * p;</p>
<p>int const * p;</p>
<p><font style="color:rgb(77, 77, 77);">注意
1：指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_var = <span class="number">8</span>;    </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p = &amp;c_var;      </span><br><span class="line">*p = <span class="number">6</span>;            <span class="comment">// error: assignment of read-only location &#x27;* p&#x27;     </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">注意
2：虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。<br>
</font><font style="color:rgb(77, 77, 77);">例如：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_var1 = <span class="number">8</span>;     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> c_var2 = <span class="number">8</span>;     </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> *p = &amp;c_var1;      </span><br><span class="line">    p = &amp;c_var2;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>指针常量：<br>
指针常量的本质上是个常量，只不过这个常量的值是一个指针。<br>
特点：const 位于指针声明操作符右侧，表明该对象本身是一个常量，*
左侧表示该指针指向的类型，即以 *
为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。</p>
<p>const int var; int * const c_p = &amp;var;</p>
<p><font style="color:rgb(77, 77, 77);">注意
1：指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="type">int</span> var, var1;     </span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> c_p = &amp;var;     </span><br><span class="line">    c_p = &amp;var1; <span class="comment">// error: assignment of read-only variable &#x27;c_p&#x27;     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">注意
2：指针的内容可以改变。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="type">int</span> var = <span class="number">3</span>;     </span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> c_p = &amp;var;     </span><br><span class="line">    *c_p = <span class="number">12</span>;      </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<h2 id="Iylg8">
<font style="color:rgb(79, 79, 79);">6.8 函数指针和指针函数的区别</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">指针函数：</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">指针函数本质是一个函数，只不过该函数的返回值是一个指针。相对于普通函数而言，只是返回值是指针。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Type</span> &#123;   <span class="type">int</span> var1;   <span class="type">int</span> var2; &#125;; </span><br><span class="line"><span class="function">Type * <span class="title">fun</span><span class="params">(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2)</span></span>&#123;     </span><br><span class="line">    Type * t = <span class="keyword">new</span> <span class="built_in">Type</span>();     </span><br><span class="line">    t-&gt;var1 = tmp1;     </span><br><span class="line">    t-&gt;var2 = tmp2;     </span><br><span class="line">    <span class="keyword">return</span> t; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    Type *p = <span class="built_in">fun</span>(<span class="number">5</span>, <span class="number">6</span>);     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">函数指针：</font></strong><font style="color:rgb(77, 77, 77);"><br>
</font><font style="color:rgb(77, 77, 77);">函数指针本质是一个指针变量，只不过这个指针指向一个函数。函数指针即指向函数的指针。</font></p>
<p><font style="color:rgb(77, 77, 77);">举例：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun1</span><span class="params">(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2)</span> </span>&#123;   <span class="keyword">return</span> tmp1 * tmp2; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun2</span><span class="params">(<span class="type">int</span> tmp1, <span class="type">int</span> tmp2)</span> </span>&#123;   <span class="keyword">return</span> tmp1 / tmp2; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">    <span class="built_in">int</span> (*fun)(<span class="type">int</span> x, <span class="type">int</span> y);    </span><br><span class="line">    fun = fun1;   </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun</span>(<span class="number">15</span>, <span class="number">5</span>) &lt;&lt; endl;    </span><br><span class="line">    fun = fun2;   </span><br><span class="line">    cout &lt;&lt; <span class="built_in">fun</span>(<span class="number">15</span>, <span class="number">5</span>) &lt;&lt; endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="comment">/* 运行结果： 75 3 */</span> </span><br></pre></td></tr></table></figure>
<p><strong><font style="color:rgb(77, 77, 77);">函数指针和指针函数的区别：</font></strong></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">本质不同<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">1.指针函数本质是一个函数，其返回值为指针。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">2.函数指针本质是一个指针变量，其指向一个函数。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">定义形式不同<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">1.指针函数：int* fun(int
tmp1, int tmp2); ，这里* 表示函数的返回值类型是指针类型。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">2.函数指针：int
(</font><em><font style="color:rgba(0, 0, 0, 0.75);">fun)(int tmp1, int
tmp2);，这里</font></em><font style="color:rgba(0, 0, 0, 0.75);">
</font><font style="color:rgba(0, 0, 0, 0.75);">表示变量本身是指针类型。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">用法不同</font></li>
</ul>
<h2 id="ZKuJI">
<font style="color:rgb(79, 79, 79);">6.9 强制类型转换有哪几种？</font>
</h2>
<ul>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">static_cast</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：用于数据的强制类型转换，强制将一种数据类型转换为另一种数据类型。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">1.用于基本数据类型的转换。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">2.用于类层次之间的基类和派生类之间
指针或者引用
的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用
dynamic_cast 进行下行转换。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">3.可以将空指针转化成目标类型的空指针。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">4.可以将任何类型的表达式转化成
void 类型。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">const_cast</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：强制去掉常量属性，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">reinterpret_cast</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型。</font></li>
<li><strong><font style="color:rgba(0, 0, 0, 0.75);">dynamic_cast</font></strong><font style="color:rgba(0, 0, 0, 0.75);">：<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">1.其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">2.只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回
NULL；不能用于基本数据类型的转换。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">3.在向上进行转换时，即派生类类的指针转换成基类类的指针和
static_cast
效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">4.在下行转换时，基类的指针类型转化为派生类类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功。</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span>     </span>&#123;cout &lt;&lt; <span class="string">&quot;Base::fun()&quot;</span> &lt;&lt; endl;&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span> : <span class="keyword">public</span> Base &#123; </span><br><span class="line"><span class="keyword">public</span>:     </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span>     </span>&#123;cout &lt;&lt; <span class="string">&quot;Derive::fun()&quot;</span> &lt;&lt; endl;&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    Base *p1 = <span class="keyword">new</span> <span class="built_in">Derive</span>();     </span><br><span class="line">    Base *p2 = <span class="keyword">new</span> <span class="built_in">Base</span>();     </span><br><span class="line">    Derive *p3 = <span class="keyword">new</span> <span class="built_in">Derive</span>();     <span class="comment">//转换成功     </span></span><br><span class="line">    p3 = <span class="built_in">dynamic_cast</span>&lt;Derive *&gt;(p1);     </span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="literal">NULL</span>)     &#123;         cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl;     &#125;     </span><br><span class="line">    <span class="keyword">else</span>     &#123;         cout &lt;&lt; <span class="string">&quot;NOT NULL&quot;</span> &lt;&lt; endl; <span class="comment">// 输出     </span></span><br><span class="line">             &#125;     <span class="comment">//转换失败     </span></span><br><span class="line">    p3 = <span class="built_in">dynamic_cast</span>&lt;Derive *&gt;(p2);     </span><br><span class="line">    <span class="keyword">if</span> (p3 == <span class="literal">NULL</span>)     &#123;         cout &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; endl; <span class="comment">// 输出     </span></span><br><span class="line">                        &#125;     <span class="keyword">else</span>     &#123;         cout &lt;&lt; <span class="string">&quot;NOT NULL&quot;</span> &lt;&lt; endl;     &#125;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<h2 id="le0Ck">
<font style="color:rgb(79, 79, 79);">6.10 如何判断结构体是否相等？能否用
memcmp 函数判断结构体相等？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">需要重载操作符 ==
判断两个结构体是否相等，不能用函数 memcmp 来判断两个结构体是否相等，因为
memcmp
函数是逐个字节进行比较的，而结构体存在内存空间中保存时存在字节对齐，字节对齐时补的字节内容是随机的，会产生垃圾值，所以无法比较。</font></p>
<p><font style="color:rgb(77, 77, 77);">利用运算符重载来实现结构体对象的比较：</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;     </span><br><span class="line">    <span class="type">char</span> c;     </span><br><span class="line">    <span class="type">int</span> val;     </span><br><span class="line">    <span class="built_in">A</span>(<span class="type">char</span> c_tmp, <span class="type">int</span> tmp) : <span class="built_in">c</span>(c_tmp), <span class="built_in">val</span>(tmp) &#123;&#125;     </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> A &amp;tmp1, <span class="type">const</span> A &amp;tmp2); <span class="comment">//  友元运算符重载函数 </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> A &amp;tmp1, <span class="type">const</span> A &amp;tmp2) &#123;     </span><br><span class="line">    <span class="built_in">return</span> (tmp1.c == tmp2.c &amp;&amp; tmp1.val == tmp2.val); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="function">A <span class="title">ex1</span><span class="params">(<span class="string">&#x27;a&#x27;</span>, <span class="number">90</span>)</span>, <span class="title">ex2</span><span class="params">(<span class="string">&#x27;b&#x27;</span>, <span class="number">80</span>)</span></span>;     </span><br><span class="line">    <span class="keyword">if</span> (ex1 == ex2)         </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ex1 == ex2&quot;</span> &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">else</span>   cout &lt;&lt; <span class="string">&quot;ex1 != ex2&quot;</span> &lt;&lt; endl; <span class="comment">// 输出     </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="D7IOx">
<font style="color:rgb(79, 79, 79);">6.11
参数传递时，值传递、引用传递、指针传递的区别？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">参数传递的三种方式：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">值传递：形参是实参的拷贝，函数对形参的所有操作不会影响实参。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">指针传递：本质上是值传递，只不过拷贝的是指针的值，拷贝之后，实参和形参是不同的指针，通过指针可以间接的访问指针所指向的对象，从而可以修改它所指对象的值。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">引用传递：当形参是引用类型时，我们说它对应的实参被引用传递。</font></li>
</ul>
<h2 id="smt7g">
<font style="color:rgb(79, 79, 79);">6.12 什么是模板？如何实现？</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">模板</font></strong><font style="color:rgb(77, 77, 77);">：创建类或者函数的蓝图或者公式，分为函数模板和类模板。<br>
</font><strong><font style="color:rgb(77, 77, 77);">实现方式</font></strong><font style="color:rgb(77, 77, 77);">：模板定义以关键字
</font><strong><font style="color:rgb(77, 77, 77);">template</font></strong><font style="color:rgb(77, 77, 77);">
开始，后跟一个模板参数列表。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">模板参数列表不能为空；</font></li>
<li>模板类型参数前必须使用关键字 class 或者
typename，在模板参数列表中这两个关键字含义相同，可互换使用。</li>
</ul>
<p>template &lt;typename T, typename U, ...&gt;</p>
<p><font style="color:rgb(77, 77, 77);">函数模板：通过定义一个函数模板，可以避免为每一种类型定义一个新函数。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">对于函数模板而言，模板类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">函数模板实例化：当调用一个模板时，编译器用函数实参来推断模板实参，从而使用实参的类型来确定绑定到模板参数的类型。</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">add_fun</span><span class="params">(<span class="type">const</span> T &amp; tmp1, <span class="type">const</span> T &amp; tmp2)</span></span>&#123;     </span><br><span class="line">    <span class="keyword">return</span> tmp1 + tmp2; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> var1, var2;     </span><br><span class="line">    cin &gt;&gt; var1 &gt;&gt; var2;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_fun</span>(var1, var2);     </span><br><span class="line">    <span class="type">double</span> var3, var4;     </span><br><span class="line">    cin &gt;&gt; var3 &gt;&gt; var4;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_fun</span>(var3, var4);     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">类模板：类似函数模板，类模板以关键字
template
开始，后跟模板参数列表。但是，编译器不能为类模板推断模板参数类型，需要在使用该类模板时，在模板名后面的尖括号中指明类型。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//构造函数     </span></span><br><span class="line">    <span class="built_in">Complex</span>(T a, T b)     &#123;         </span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;         </span><br><span class="line">        <span class="keyword">this</span>-&gt;b = b;     &#125;     <span class="comment">//运算符重载     </span></span><br><span class="line">    Complex&lt;T&gt; <span class="keyword">operator</span>+(Complex &amp;c)     &#123;         </span><br><span class="line">        <span class="function">Complex&lt;T&gt; <span class="title">tmp</span><span class="params">(<span class="keyword">this</span>-&gt;a + c.a, <span class="keyword">this</span>-&gt;b + c.b)</span></span>;         </span><br><span class="line">        cout &lt;&lt; tmp.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tmp.b &lt;&lt; endl;         </span><br><span class="line">        <span class="keyword">return</span> tmp;     &#125; </span><br><span class="line"><span class="keyword">private</span>:     </span><br><span class="line">    T a;     </span><br><span class="line">    T b; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;     </span><br><span class="line">    <span class="function">Complex&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">20</span>, <span class="number">30</span>)</span></span>;     </span><br><span class="line">    Complex&lt;<span class="type">int</span>&gt; c = a + b;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure>
<h2 id="nWycn">
<font style="color:rgb(79, 79, 79);">6.13
函数模板和类模板的区别？</font>
</h2>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">实例化方式不同：函数模板实例化由编译程序在处理函数调用时自动完成，类模板实例化需要在程序中显式指定。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">实例化的结果不同：函数模板实例化后是一个函数，类模板实例化后是一个类。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">默认参数：类模板在模板参数列表中可以有默认参数。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">特化：函数模板只能全特化；而类模板可以全特化，也可以偏特化。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">调用方式不同：函数模板可以隐式调用，也可以显式调用；类模板只能显式调用。<br>
</font><font style="color:rgba(0, 0, 0, 0.75);">函数模板调用方式举例：</font></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">add_fun</span><span class="params">(<span class="type">const</span> T &amp; tmp1, <span class="type">const</span> T &amp; tmp2)</span></span>&#123;     <span class="keyword">return</span> tmp1 + tmp2; &#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    <span class="type">int</span> var1, var2;     </span><br><span class="line">    cin &gt;&gt; var1 &gt;&gt; var2;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_fun</span>&lt;<span class="type">int</span>&gt;(var1, var2); <span class="comment">// 显式调用     </span></span><br><span class="line">    <span class="type">double</span> var3, var4;     </span><br><span class="line">    cin &gt;&gt; var3 &gt;&gt; var4;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">add_fun</span>(var3, var4); <span class="comment">// 隐式调用     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="EPJ50">
<font style="color:rgb(79, 79, 79);">6.14 什么是可变参数模板？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">可变参数模板：接受可变数目参数的模板函数或模板类。将可变数目的参数被称为参数包，包括模板参数包和函数参数包。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">模板参数包：表示零个或多个模板参数；</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">函数参数包：表示零个或多个函数参数。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">用省略号来指出一个模板参数或函数参数表示一个包，在模板参数列表中，class…
或 typename…
指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。当需要知道包中有多少元素时，可以使用
sizeof… 运算符。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="comment">// Args 是模板参数包 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args&amp;... rest)</span></span>; <span class="comment">// 可变参数模板，rest 是函数参数包 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span> <span class="title">print_fun</span><span class="params">(<span class="type">const</span> T &amp;t)</span> </span>&#123;     </span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl; <span class="comment">// 最后一个元素 </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt; <span class="function"><span class="type">void</span> <span class="title">print_fun</span><span class="params">(<span class="type">const</span> T &amp;t, <span class="type">const</span> Args &amp;...args)</span> </span>&#123;     </span><br><span class="line">    cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;     </span><br><span class="line">    <span class="built_in">print_fun</span>(args...); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">    <span class="built_in">print_fun</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;wolrd&quot;</span>, <span class="string">&quot;!&quot;</span>);     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; <span class="comment">/*运行结果： Hello wolrd ! */</span> </span><br></pre></td></tr></table></figure>
<p><font style="color:rgb(77, 77, 77);">说明：可变参数函数通常是递归的，第一个版本的
print_fun 负责终止递归并打印初始调用中的最后一个实参。第二个版本的
print_fun 是可变参数版本，打印绑定到 t
的实参，并用来调用自身来打印函数参数包中的剩余值。</font></p>
<h2 id="wedl8">
<font style="color:rgb(79, 79, 79);">6.15
什么是模板特化？为什么特化？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">模板特化的原因：模板并非对任何模板实参都合适、都能实例化，某些情况下，通用模板的定义对特定类型不合适，可能会编译失败，或者得不到正确的结果。因此，当不希望使用模板版本时，可以定义类或者函数模板的一个特例化版本。</font></p>
<p><font style="color:rgb(77, 77, 77);">模板特化：模板参数在某种特定类型下的具体实现。分为函数模板特化和类模板特化</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">函数模板特化：将函数模板中的全部类型进行特例化，称为函数模板特化。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">类模板特化：将类模板中的部分或全部类型进行特例化，称为类模板特化。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">特化分为全特化和偏特化：</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">全特化：模板中的模板参数全部特例化。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">偏特化：模板中的模板参数只确定了一部分，剩余部分需要在编译器编译时确定。</font></li>
</ul>
<p><font style="color:rgb(77, 77, 77);">说明：要区分下函数重载与函数模板特化<br>
</font><font style="color:rgb(77, 77, 77);">定义函数模板的特化版本，本质上是接管了编译器的工作，为原函数模板定义了一个特殊实例，而不是函数重载，函数模板特化并不影响函数匹配。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">//函数模板 </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(T t1, T t2)</span> </span>&#123;     </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;通用版本：&quot;</span>;     </span><br><span class="line">    <span class="keyword">return</span> t1 == t2; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">template</span> &lt;&gt;  <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">char</span> *t1, <span class="type">char</span> *t2)</span> </span>&#123;     </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;特化版本：&quot;</span>;     </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(t1, t2) == <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;     </span><br><span class="line">    <span class="type">char</span> arr1[] = <span class="string">&quot;hello&quot;</span>;     </span><br><span class="line">    <span class="type">char</span> arr2[] = <span class="string">&quot;abc&quot;</span>;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(<span class="number">123</span>, <span class="number">123</span>) &lt;&lt; endl;     </span><br><span class="line">    cout &lt;&lt; <span class="built_in">compare</span>(arr1, arr2) &lt;&lt; endl;     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125; <span class="comment">/* 运行结果： 通用版本：1 特化版本：0 */</span> </span><br></pre></td></tr></table></figure>
<h2 id="ZiykO">
<font style="color:rgb(79, 79, 79);">6.16 include " " 和 &lt;&gt;
的区别</font>
</h2>
<p><strong><font style="color:rgb(77, 77, 77);">include<文件名></文件名></font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">和</font><font style="color:rgb(77, 77, 77);">
</font><strong><font style="color:rgb(77, 77, 77);">#include"文件名"</font></strong><font style="color:rgb(77, 77, 77);">
</font><font style="color:rgb(77, 77, 77);">的区别:</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">查找文件的位置：include<文件名>在标准库头文件所在的目录中查找，如果没有，再到当前源文件所在目录下查找；#include"文件名"
在当前源文件所在目录中进行查找，如果没有；再到系统目录中查找。</文件名></font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">使用习惯：对于标准库中的头文件常用
include<文件名>，对于自己定义的头文件，常用 #include"文件名"</文件名></font></li>
</ul>
<h2 id="a91WF">
<font style="color:rgb(79, 79, 79);">6.17 泛型编程如何实现？</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">泛型编程实现的基础：模板。模板是创建类或者函数的蓝图或者说公式，当时用一个
vector 这样的泛型，或者 find
这样的泛型函数时，编译时会转化为特定的类或者函数。</font></p>
<p><font style="color:rgb(77, 77, 77);">泛型编程涉及到的知识点较广，例如：容器、迭代器、算法等都是泛型编程的实现实例。面试者可选择自己掌握比较扎实的一方面进行展开。</font></p>
<ul>
<li><font style="color:rgba(0, 0, 0, 0.75);">容器：涉及到 STL
中的容器，例如：vector、list、map
等，可选其中熟悉底层原理的容器进行展开讲解。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">迭代器：在无需知道容器底层原理的情况下，遍历容器中的元素。</font></li>
<li><font style="color:rgba(0, 0, 0, 0.75);">模板：可参考本章节中的模板相关问题。</font></li>
</ul>
<h2 id="ySyMq">
<font style="color:rgb(79, 79, 79);">6.18 C++命名空间</font>
</h2>
<p><font style="color:rgb(77, 77, 77);">使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突。在C++中，变量、函数和类都是大量存在的。如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，会导致很多冲突。比如，如果我们在自己的程序中定义了一个函functionA()，这将重写标准库中的functionA()函
数，这是因为这两个函数都是位于全局命名空间中的</font></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Mello13</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://skylersuen.github.io/2024/08/12/C++突击面试/">https://skylersuen.github.io/2024/08/12/C++突击面试/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2024/09/30/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E9%9D%A2%E7%BB%8F/"><i class="fa fa-chevron-left">  </i><span>大模型面经</span></a></div><div class="next-post pull-right"><a href="/2024/04/26/%E5%B0%8F%E7%B1%B3%E4%B8%80%E9%9D%A2%E9%9D%A2%E7%BB%8F/"><span>小米一面面经</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/SkylerSuen/PicBase/master/topimg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 - 2024 By Mello13</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">if you have any suggestion, please contact me at syf_mello@163.com !</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>